# -*- Mode: Python -*-

# GDBus - GLib D-Bus Library
#
# Copyright (C) 2008-2011 Red Hat, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General
# Public License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place, Suite 330,
# Boston, MA 02111-1307, USA.
#
# Author: David Zeuthen <davidz@redhat.com>

import sys
import argparse
import distutils.version

import config
import utils
import dbustypes

# ----------------------------------------------------------------------------------------------------

class CodeGenerator:
    def __init__(self, ifaces, namespace, interface_prefix, generate_objmanager, h, c):
        self.generate_objmanager = generate_objmanager
        self.ifaces = ifaces
        self.h = h
        self.c = c
        self.namespace = namespace
        if len(namespace) > 1:
            self.ns_upper = utils.camel_case_to_uscore(namespace).upper() + '_'
            self.ns_lower = utils.camel_case_to_uscore(namespace).lower() + '_'
        else:
            self.ns_upper = ''
            self.ns_lower = ''
        self.interface_prefix = interface_prefix
        self.header_guard = self.h.name.upper().replace('.', '_').replace('-', '_')

    # ----------------------------------------------------------------------------------------------------

    def generate_intro(self):
        self.c.write('/*\n'
                     ' * Generated by gdbus-codegen %s. DO NOT EDIT.\n'
                     ' *\n'
                     ' * The license of this code is the same as for the source it was derived from.\n'
                     ' */\n'
                     '\n'
                     %(config.VERSION))
        self.c.write('#ifdef HAVE_CONFIG_H\n'
                     '#  include "config.h"\n'
                     '#endif\n'
                     '\n'
                     '#include "%s"\n'
                     '\n'%(self.h.name))

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusArgInfo parent_struct;\n'
                     '  gboolean use_gvariant;\n'
                     '} _ExtendedGDBusArgInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusMethodInfo parent_struct;\n'
                     '  const gchar *signal_name;\n'
                     '} _ExtendedGDBusMethodInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusSignalInfo parent_struct;\n'
                     '  const gchar *signal_name;\n'
                     '} _ExtendedGDBusSignalInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusPropertyInfo parent_struct;\n'
                     '  const gchar *hyphen_name;\n'
                     '  gboolean use_gvariant;\n'
                     '} _ExtendedGDBusPropertyInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  const _ExtendedGDBusPropertyInfo *info;\n'
                     '  guint prop_id;\n'
                     '  GValue orig_value; /* the value before the change */\n'
                     '} ChangedProperty;\n'
                     '\n'
                     'static void\n'
                     '_changed_property_free (ChangedProperty *data)\n'
                     '{\n'
                     '  g_value_unset (&data->orig_value);\n'
                     '  g_free (data);\n'
                     '}\n'
                     '\n')

        self.c.write('static gboolean\n'
                     '_g_strv_equal0 (gchar **a, gchar **b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  guint n;\n'
                     '  if (a == NULL && b == NULL)\n'
                     '    {\n'
                     '      ret = TRUE;\n'
                     '      goto out;\n'
                     '    }\n'
                     '  if (a == NULL || b == NULL)\n'
                     '    goto out;\n'
                     '  if (g_strv_length (a) != g_strv_length (b))\n'
                     '    goto out;\n'
                     '  for (n = 0; a[n] != NULL; n++)\n'
                     '    if (g_strcmp0 (a[n], b[n]) != 0)\n'
                     '      goto out;\n'
                     '  ret = TRUE;\n'
                     'out:\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        self.c.write('static gboolean\n'
                     '_g_variant_equal0 (GVariant *a, GVariant *b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  if (a == NULL && b == NULL)\n'
                     '    {\n'
                     '      ret = TRUE;\n'
                     '      goto out;\n'
                     '    }\n'
                     '  if (a == NULL || b == NULL)\n'
                     '    goto out;\n'
                     '  ret = g_variant_equal (a, b);\n'
                     'out:\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        # simplified - only supports the types we use
        self.c.write('static gboolean\n'
                     '_g_value_equal (const GValue *a, const GValue *b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));\n'
                     '  switch (G_VALUE_TYPE (a))\n'
                     '    {\n'
                     '      case G_TYPE_BOOLEAN:\n'
                     '        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UCHAR:\n'
                     '        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));\n'
                     '        break;\n'
                     '      case G_TYPE_INT:\n'
                     '        ret = (g_value_get_int (a) == g_value_get_int (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UINT:\n'
                     '        ret = (g_value_get_uint (a) == g_value_get_uint (b));\n'
                     '        break;\n'
                     '      case G_TYPE_INT64:\n'
                     '        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UINT64:\n'
                     '        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));\n'
                     '        break;\n'
                     '      case G_TYPE_DOUBLE:\n'
                     '        ret = (g_value_get_double (a) == g_value_get_double (b));\n'
                     '        break;\n'
                     '      case G_TYPE_STRING:\n'
                     '        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);\n'
                     '        break;\n'
                     '      case G_TYPE_VARIANT:\n'
                     '        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));\n'
                     '        break;\n'
                     '      default:\n'
                     '        if (G_VALUE_TYPE (a) == G_TYPE_STRV)\n'
                     '          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));\n'
                     '        else\n'
                     '          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));\n'
                     '        break;\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        self.h.write('/*\n'
                     ' * Generated by gdbus-codegen %s. DO NOT EDIT.\n'
                     ' *\n'
                     ' * The license of this code is the same as for the source it was derived from.\n'
                     ' */\n'
                     '\n'
                     '#ifndef __%s__\n'
                     '#define __%s__\n'
                     '\n'%(config.VERSION, self.header_guard, self.header_guard))
        self.h.write('#include <gio/gio.h>\n'
                     '\n'
                     'G_BEGIN_DECLS\n'
                     '\n')

    # ----------------------------------------------------------------------------------------------------

    def declare_types(self):
        for i in self.ifaces:
            self.h.write('\n')
            self.h.write('/* ------------------------------------------------------------------------ */\n')
            self.h.write('/* Declarations for %s */\n'%i.name)
            self.h.write('\n')

            # First the GInterface
            self.h.write('#define %sTYPE_%s (%s_get_type ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s, %s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %s%s_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_%s, %s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%s;\n'%(i.camel_name))
            self.h.write('typedef struct _%s %s;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sIface %sIface;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sIface\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GTypeInterface parent_iface;\n')

            function_pointers = {}

            if len(i.methods) > 0:
                self.h.write('\n')
                for m in i.methods:
                    key = (m.since, '_method_%s'%m.name_lower)
                    value  = '  gboolean (*handle_%s) (\n'%(m.name_lower)
                    value += '    %s *object,\n'%(i.camel_name)
                    value += '    GDBusMethodInvocation *invocation'%()
                    for a in m.in_args:
                        value += ',\n    %s%s'%(a.ctype_in, a.name)
                    value += ');\n\n'
                    function_pointers[key] = value

            if len(i.signals) > 0:
                self.h.write('\n')
                for s in i.signals:
                    key = (s.since, '_signal_%s'%s.name_lower)
                    value  = '  void (*%s) (\n'%(s.name_lower)
                    value += '    %s *object'%(i.camel_name)
                    for a in s.args:
                        value += ',\n    %s%s'%(a.ctype_in, a.name)
                    value += ');\n\n'
                    function_pointers[key] = value

            # Sort according to @since tag, then name.. this ensures
            # that the function pointers don't change order assuming
            # judicious use of @since
            #
            # Also use a proper version comparison function so e.g.
            # 10.0 comes after 2.0.
            #
            # See https://bugzilla.gnome.org/show_bug.cgi?id=647577#c5
            # for discussion

            # I'm sure this could be a lot more elegant if I was
            # more fluent in python...
            def my_version_cmp(a, b):
                if len(a[0]) > 0 and len(b[0]) > 0:
                    va = distutils.version.LooseVersion(a[0])
                    vb = distutils.version.LooseVersion(b[0])
                    ret = va.__cmp__(vb)
                else:
                    ret = cmp(a[0], b[0])
                if ret != 0:
                    return ret
                return cmp(a[1], b[1])
            keys = function_pointers.keys()
            if len(keys) > 0:
                keys.sort(cmp=my_version_cmp)
                for key in keys:
                    self.h.write('%s'%function_pointers[key])

            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_get_type (void) G_GNUC_CONST;\n'%(i.name_lower))
            self.h.write('\n')
            self.h.write('GDBusInterfaceInfo *%s_interface_info (void);\n'%(i.name_lower))
            if len(i.properties) > 0:
                self.h.write('guint %s_override_properties (GObjectClass *klass, guint property_id_begin);\n'%(i.name_lower))
            self.h.write('\n')

            # Then method call completion functions
            if len(i.methods) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus method call completion functions: */\n')
                for m in i.methods:
                    if m.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('void %s_complete_%s (\n'
                                 '    %s *object,\n'
                                 '    GDBusMethodInvocation *invocation'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.out_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then signal emission functions
            if len(i.signals) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus signal emissions functions: */\n')
                for s in i.signals:
                    if s.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('void %s_emit_%s (\n'
                                 '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
                    for a in s.args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then method call declarations
            if len(i.methods) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus method calls: */\n')
                for m in i.methods:
                    # async begin
                    if m.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('void %s_call_%s (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.in_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(',\n'
                                 '    GCancellable *cancellable,\n'
                                 '    GAsyncReadyCallback callback,\n'
                                 '    gpointer user_data);\n')
                    self.h.write('\n')
                    # async finish
                    if m.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('gboolean %s_call_%s_finish (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.out_args:
                        self.h.write(',\n    %sout_%s'%(a.ctype_out, a.name))
                    self.h.write(',\n'
                                 '    GAsyncResult *res,\n'
                                 '    GError **error);\n')
                    self.h.write('\n')
                    # sync
                    if m.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('gboolean %s_call_%s_sync (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.in_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    for a in m.out_args:
                        self.h.write(',\n    %sout_%s'%(a.ctype_out, a.name))
                    self.h.write(',\n'
                                 '    GCancellable *cancellable,\n'
                                 '    GError **error);\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then the property accessor declarations
            if len(i.properties) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus property accessors: */\n')
                for p in i.properties:
                    # getter
                    if p.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('%s%s_get_%s (%s *object);\n'%(p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name))
                    # setter
                    if p.deprecated:
                        self.h.write('G_GNUC_DEPRECATED ')
                    self.h.write('void %s_set_%s (%s *object, %svalue);\n'%(i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in, ))
                    self.h.write('\n')

            # Then the proxy
            self.h.write('\n')
            self.h.write('/* ---- */\n')
            self.h.write('\n')
            self.h.write('#define %sTYPE_%s_PROXY (%s_proxy_get_type ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_PROXY, %sProxy))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_PROXY, %sProxyClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_PROXY, %sProxyClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_PROXY))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %sIS_%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_PROXY))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('\n')
            self.h.write('typedef struct _%sProxy %sProxy;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sProxyClass %sProxyClass;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sProxyPrivate %sProxyPrivate;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sProxy\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusProxy parent_instance;\n')
            self.h.write('  %sProxyPrivate *priv;\n'%(i.camel_name))
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('struct _%sProxyClass\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusProxyClass parent_class;\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_proxy_get_type (void) G_GNUC_CONST;\n'%(i.name_lower))

            self.h.write('\n')
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('void %s_proxy_new (\n'
                         '    GDBusConnection     *connection,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GAsyncReadyCallback  callback,\n'
                         '    gpointer             user_data);\n'
                         %(i.name_lower))
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('%s *%s_proxy_new_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('%s *%s_proxy_new_sync (\n'
                         '    GDBusConnection     *connection,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('\n')
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('void %s_proxy_new_for_bus (\n'
                         '    GBusType             bus_type,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GAsyncReadyCallback  callback,\n'
                         '    gpointer             user_data);\n'
                         %(i.name_lower))
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('%s *%s_proxy_new_for_bus_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('%s *%s_proxy_new_for_bus_sync (\n'
                         '    GBusType             bus_type,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('\n')

            # Interface proxy accessors
            self.h.write('#define %sGET_%s(object) (g_dbus_object_lookup_with_typecheck (G_DBUS_OBJECT (object), "%s", %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
            self.h.write('#define %sPEEK_%s(object) (g_dbus_object_peek_with_typecheck (G_DBUS_OBJECT (object), "%s", %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
            self.h.write('\n')

            # Then the skeleton
            self.h.write('\n')
            self.h.write('/* ---- */\n')
            self.h.write('\n')
            self.h.write('#define %sTYPE_%s_SKELETON (%s_skeleton_get_type ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_SKELETON, %sSkeleton))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_SKELETON, %sSkeletonClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_SKELETON, %sSkeletonClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_SKELETON))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %sIS_%s_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_SKELETON))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('\n')
            self.h.write('typedef struct _%sSkeleton %sSkeleton;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sSkeletonClass %sSkeletonClass;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sSkeletonPrivate %sSkeletonPrivate;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sSkeleton\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusInterfaceSkeleton parent_instance;\n')
            self.h.write('  %sSkeletonPrivate *priv;\n'%(i.camel_name))
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('struct _%sSkeletonClass\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusInterfaceSkeletonClass parent_class;\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_skeleton_get_type (void) G_GNUC_CONST;\n'%(i.name_lower))
            self.h.write('\n')
            if i.deprecated:
                self.h.write('G_GNUC_DEPRECATED ')
            self.h.write('%s *%s_skeleton_new (void);\n'%(i.camel_name, i.name_lower))

            self.h.write('\n')

        # Finally, the proxy manager
        if self.generate_objmanager:
            self.h.write('\n')
            self.h.write('/* ---- */\n')
            self.h.write('\n')
            self.h.write('#define %sTYPE_OBJECT_MANAGER_CLIENT (%sobject_manager_client_get_type ())\n'%(self.ns_upper, self.ns_lower))
            self.h.write('#define %sOBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClient))\n'%(self.ns_upper, self.ns_upper, self.namespace))
            self.h.write('#define %sOBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n'%(self.ns_upper, self.ns_upper, self.namespace))
            self.h.write('#define %sOBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n'%(self.ns_upper, self.ns_upper, self.namespace))
            self.h.write('#define %sIS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_MANAGER_CLIENT))\n'%(self.ns_upper, self.ns_upper))
            self.h.write('#define %sIS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_MANAGER_CLIENT))\n'%(self.ns_upper, self.ns_upper))
            self.h.write('\n')
            self.h.write('typedef struct _%sObjectManagerClient %sObjectManagerClient;\n'%(self.namespace, self.namespace))
            self.h.write('typedef struct _%sObjectManagerClientClass %sObjectManagerClientClass;\n'%(self.namespace, self.namespace))
            self.h.write('typedef struct _%sObjectManagerClientPrivate %sObjectManagerClientPrivate;\n'%(self.namespace, self.namespace))
            self.h.write('\n')
            self.h.write('struct _%sObjectManagerClient\n'%(self.namespace))
            self.h.write('{\n')
            self.h.write('  GDBusObjectManagerClient parent_instance;\n')
            self.h.write('  %sObjectManagerClientPrivate *priv;\n'%(self.namespace))
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('struct _%sObjectManagerClientClass\n'%(self.namespace))
            self.h.write('{\n')
            self.h.write('  GDBusObjectManagerClientClass parent_class;\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %sobject_manager_client_get_type (void) G_GNUC_CONST;\n'%(self.ns_lower))
            self.h.write('\n')
            self.h.write('GType %sobject_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data);\n'%(self.ns_lower))
            self.h.write('\n')
            self.h.write('void %sobject_manager_client_new (\n'
                         '    GDBusConnection        *connection,\n'
                         '    GDBusObjectManagerClientFlags  flags,\n'
                         '    const gchar            *name,\n'
                         '    const gchar            *object_path,\n'
                         '    GCancellable           *cancellable,\n'
                         '    GAsyncReadyCallback     callback,\n'
                         '    gpointer                user_data);\n'
                         %(self.ns_lower))
            self.h.write('GDBusObjectManager *%sobject_manager_client_new_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(self.ns_lower))
            self.h.write('GDBusObjectManager *%sobject_manager_client_new_sync (\n'
                         '    GDBusConnection        *connection,\n'
                         '    GDBusObjectManagerClientFlags  flags,\n'
                         '    const gchar            *name,\n'
                         '    const gchar            *object_path,\n'
                         '    GCancellable           *cancellable,\n'
                         '    GError                **error);\n'
                         %(self.ns_lower))
            self.h.write('\n')
            self.h.write('void %sobject_manager_client_new_for_bus (\n'
                         '    GBusType                bus_type,\n'
                         '    GDBusObjectManagerClientFlags  flags,\n'
                         '    const gchar            *name,\n'
                         '    const gchar            *object_path,\n'
                         '    GCancellable           *cancellable,\n'
                         '    GAsyncReadyCallback     callback,\n'
                         '    gpointer                user_data);\n'
                         %(self.ns_lower))
            self.h.write('GDBusObjectManager *%sobject_manager_client_new_for_bus_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(self.ns_lower))
            self.h.write('GDBusObjectManager *%sobject_manager_client_new_for_bus_sync (\n'
                         '    GBusType                bus_type,\n'
                         '    GDBusObjectManagerClientFlags  flags,\n'
                         '    const gchar            *name,\n'
                         '    const gchar            *object_path,\n'
                         '    GCancellable           *cancellable,\n'
                         '    GError                **error);\n'
                         %(self.ns_lower))
            self.h.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_outro(self):
        self.h.write('\n'
                     'G_END_DECLS\n'
                     '\n'
                     '#endif /* __%s__ */\n'%(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate_annotations(self, prefix, annotations):
        if annotations == None:
            return

        n = 0
        for a in annotations:
            #self.generate_annotations('%s_%d'%(prefix, n), a.get_annotations())

            # skip internal annotations
            if a.key.startswith('org.gtk.GDBus'):
                continue

            self.c.write('static const GDBusAnnotationInfo %s_%d =\n'
                         '{\n'
                         '  -1,\n'
                         '  "%s",\n'
                         '  "%s",\n'%(prefix, n, a.key, a.value))
            if len(a.annotations) == 0:
                self.c.write('  NULL\n')
            else:
                self.c.write('  (GDBusAnnotationInfo **) &%s_%d_pointers\n'%(prefix, n))
            self.c.write('};\n'
                         '\n')
            n += 1

        if n > 0:
            self.c.write('static const GDBusAnnotationInfo * const %s_pointers[] =\n'
                             '{\n'%(prefix))
            m = 0;
            for a in annotations:
                if a.key.startswith('org.gtk.GDBus'):
                    continue
                self.c.write('  &%s_%d,\n'%(prefix, m))
                m += 1
            self.c.write('  NULL\n'
                         '};\n'
                         '\n')
        return n

    def generate_args(self, prefix, args):
        for a in args:
            num_anno = self.generate_annotations('%s_arg_%s_annotation_info'%(prefix, a.name), a.annotations)

            self.c.write('static const _ExtendedGDBusArgInfo %s_%s =\n'
                         '{\n'
                         '  {\n'
                         '    -1,\n'
                         '    "%s",\n'
                         '    "%s",\n'%(prefix, a.name, a.name, a.signature))
            if num_anno == 0:
                self.c.write('    NULL\n')
            else:
                self.c.write('    (GDBusAnnotationInfo **) &%s_arg_%s_annotation_info_pointers\n'%(prefix, a.name))
            self.c.write('  },\n')
            if not utils.lookup_annotation(a.annotations, 'org.gtk.GDBus.C.ForceGVariant'):
                self.c.write('  FALSE\n')
            else:
                self.c.write('  TRUE\n')
            self.c.write('};\n'
                         '\n')

        if len(args) > 0:
            self.c.write('static const _ExtendedGDBusArgInfo * const %s_pointers[] =\n'
                             '{\n'%(prefix))
            for a in args:
                self.c.write('  &%s_%s,\n'%(prefix, a.name))
            self.c.write('  NULL\n'
                         '};\n'
                         '\n')

    def generate_introspection_for_interface(self, i):
            self.c.write('/* ---- Introspection data for %s ---- */\n'
                         '\n'%(i.name))

            if len(i.methods) > 0:
                for m in i.methods:
                    self.generate_args('_%s_method_info_%s_IN_ARG'%(i.name_lower, m.name_lower), m.in_args)
                    self.generate_args('_%s_method_info_%s_OUT_ARG'%(i.name_lower, m.name_lower), m.out_args)

                    num_anno = self.generate_annotations('_%s_method_%s_annotation_info'%(i.name_lower, m.name_lower), m.annotations)

                    self.c.write('static const _ExtendedGDBusMethodInfo _%s_method_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'%(i.name_lower, m.name_lower, m.name))
                    if len(m.in_args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_method_info_%s_IN_ARG_pointers,\n'%(i.name_lower, m.name_lower))
                    if len(m.out_args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_method_info_%s_OUT_ARG_pointers,\n'%(i.name_lower, m.name_lower))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_method_%s_annotation_info_pointers\n'%(i.name_lower, m.name_lower))
                    self.c.write('  },\n'
                                 '  "handle-%s"\n'
                                 %(m.name_hyphen))
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusMethodInfo * const _%s_method_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for m in i.methods:
                    self.c.write('  &_%s_method_info_%s,\n'%(i.name_lower, m.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            # ---

            if len(i.signals) > 0:
                for s in i.signals:
                    self.generate_args('_%s_signal_info_%s_ARG'%(i.name_lower, s.name_lower), s.args)

                    num_anno = self.generate_annotations('_%s_signal_%s_annotation_info'%(i.name_lower, s.name_lower), s.annotations)
                    self.c.write('static const _ExtendedGDBusSignalInfo _%s_signal_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'%(i.name_lower, s.name_lower, s.name))
                    if len(s.args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_signal_info_%s_ARG_pointers,\n'%(i.name_lower, s.name_lower))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_signal_%s_annotation_info_pointers\n'%(i.name_lower, s.name_lower))
                    self.c.write('  },\n'
                                 '  "%s"\n'
                                 %(s.name_hyphen))
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusSignalInfo * const _%s_signal_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for s in i.signals:
                    self.c.write('  &_%s_signal_info_%s,\n'%(i.name_lower, s.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            # ---

            if len(i.properties) > 0:
                for p in i.properties:
                    if p.readable and p.writable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE'
                    elif p.readable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_READABLE'
                    elif p.writable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE'
                    else:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_NONE'
                    num_anno = self.generate_annotations('_%s_property_%s_annotation_info'%(i.name_lower, p.name_lower), p.annotations)
                    self.c.write('static const _ExtendedGDBusPropertyInfo _%s_property_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'
                                 '    "%s",\n'
                                 '    %s,\n'%(i.name_lower, p.name_lower, p.name, p.arg.signature, access))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_property_%s_annotation_info_pointers\n'%(i.name_lower, p.name_lower))
                    self.c.write('  },\n'
                                 '  "%s",\n'
                                 %(p.name_hyphen))
                    if not utils.lookup_annotation(p.annotations, 'org.gtk.GDBus.C.ForceGVariant'):
                        self.c.write('  FALSE\n')
                    else:
                        self.c.write('  TRUE\n')
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusPropertyInfo * const _%s_property_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for p in i.properties:
                    self.c.write('  &_%s_property_info_%s,\n'%(i.name_lower, p.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            num_anno = self.generate_annotations('_%s_annotation_info'%(i.name_lower), i.annotations)
            self.c.write('static const GDBusInterfaceInfo _%s_interface_info =\n'
                         '{\n'
                         '  -1,\n'
                         '  "%s",\n'%(i.name_lower, i.name))
            if len(i.methods) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusMethodInfo **) &_%s_method_info_pointers,\n'%(i.name_lower))
            if len(i.signals) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusSignalInfo **) &_%s_signal_info_pointers,\n'%(i.name_lower))
            if len(i.properties) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusPropertyInfo **) &_%s_property_info_pointers,\n'%(i.name_lower))
            if num_anno == 0:
                self.c.write('  NULL\n')
            else:
                self.c.write('  (GDBusAnnotationInfo **) &_%s_annotation_info_pointers\n'%(i.name_lower))
            self.c.write('};\n'
                         '\n')
            self.c.write('\n')
            self.c.write('GDBusInterfaceInfo *\n'
                         '%s_interface_info (void)\n'
                         '{\n'
                         '  return (GDBusInterfaceInfo *) &_%s_interface_info;\n'
                         '}\n'
                         '\n'%(i.name_lower, i.name_lower))

            if len(i.properties) > 0:
                self.c.write('guint\n'
                             '%s_override_properties (GObjectClass *klass, guint property_id_begin)\n'
                             '{\n'%(i.name_lower))
                for p in i.properties:
                    self.c.write ('  g_object_class_override_property (klass, property_id_begin++, "%s");\n'%(p.name_hyphen))
                self.c.write('  return property_id_begin - 1;\n'
                             '}\n'
                             '\n')
            self.c.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_interface(self, i):
        self.c.write('\n')

        self.c.write('static void\n'
                     '%s_default_init (%sIface *iface)\n'
                     '{\n'%(i.name_lower, i.camel_name));

        if len(i.methods) > 0:
            self.c.write('  /* GObject signals for incoming D-Bus method calls: */\n')
            for m in i.methods:
                self.c.write('  g_signal_new ("handle-%s",\n'
                             '    G_TYPE_FROM_INTERFACE (iface),\n'
                             '    G_SIGNAL_RUN_LAST,\n'
                             '    G_STRUCT_OFFSET (%sIface, handle_%s),\n'
                             '    g_signal_accumulator_true_handled,\n'
                             '    NULL,\n' # accu_data
                             '    g_cclosure_marshal_generic,\n'
                             '    G_TYPE_BOOLEAN,\n'
                             '    %d,\n'
                             '    G_TYPE_DBUS_METHOD_INVOCATION'
                             %(m.name_hyphen, i.camel_name, m.name_lower, len(m.in_args) + 1))
                for a in m.in_args:
                    self.c.write (', %s'%(a.gtype))
                self.c.write(');\n')
                self.c.write('\n')

        if len(i.signals) > 0:
            self.c.write('  /* GObject signals for received D-Bus signals: */\n')
            for s in i.signals:
                self.c.write('  g_signal_new ("%s",\n'
                             '    G_TYPE_FROM_INTERFACE (iface),\n'
                             '    G_SIGNAL_RUN_LAST,\n'
                             '    G_STRUCT_OFFSET (%sIface, %s),\n'
                             '    NULL,\n' # accumulator
                             '    NULL,\n' # accu_data
                             '    g_cclosure_marshal_generic,\n'
                             '    G_TYPE_NONE,\n'
                             '    %d'
                             %(s.name_hyphen, i.camel_name, s.name_lower, len(s.args)))
                for a in s.args:
                    self.c.write (', %s'%(a.gtype))
                self.c.write(');\n')
                self.c.write('\n')

        if len(i.properties) > 0:
            self.c.write('  /* GObject properties for D-Bus properties: */\n')
            for p in i.properties:
                self.c.write('  g_object_interface_install_property (iface,\n')
                if p.arg.gtype == 'G_TYPE_VARIANT':
                    s = 'g_param_spec_variant ("%s", NULL, NULL, G_VARIANT_TYPE ("%s"), NULL'%(p.name_hyphen, p.arg.signature)
                elif p.arg.signature == 'b':
                    s = 'g_param_spec_boolean ("%s", NULL, NULL, FALSE'%(p.name_hyphen)
                elif p.arg.signature == 'y':
                    s = 'g_param_spec_uchar ("%s", NULL, NULL, 0, 255, 0'%(p.name_hyphen)
                elif p.arg.signature == 'n':
                    s = 'g_param_spec_int ("%s", NULL, NULL, G_MININT16, G_MAXINT16, 0'%(p.name_hyphen)
                elif p.arg.signature == 'q':
                    s = 'g_param_spec_uint ("%s", NULL, NULL, 0, G_MAXUINT16, 0'%(p.name_hyphen)
                elif p.arg.signature == 'i':
                    s = 'g_param_spec_int ("%s", NULL, NULL, G_MININT32, G_MAXINT32, 0'%(p.name_hyphen)
                elif p.arg.signature == 'u':
                    s = 'g_param_spec_uint ("%s", NULL, NULL, 0, G_MAXUINT32, 0'%(p.name_hyphen)
                elif p.arg.signature == 'x':
                    s = 'g_param_spec_int64 ("%s", NULL, NULL, G_MININT64, G_MAXINT64, 0'%(p.name_hyphen)
                elif p.arg.signature == 't':
                    s = 'g_param_spec_uint64 ("%s", NULL, NULL, 0, G_MAXUINT64, 0'%(p.name_hyphen)
                elif p.arg.signature == 'd':
                    s = 'g_param_spec_double ("%s", NULL, NULL, -G_MAXDOUBLE, G_MAXDOUBLE, 0.0'%(p.name_hyphen)
                elif p.arg.signature == 's':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'o':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'g':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'ay':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'as':
                    s = 'g_param_spec_boxed ("%s", NULL, NULL, G_TYPE_STRV'%(p.name_hyphen)
                elif p.arg.signature == 'aay':
                    s = 'g_param_spec_boxed ("%s", NULL, NULL, G_TYPE_STRV'%(p.name_hyphen)
                else:
                    raise RuntimeError('Unsupported gtype %s for GParamSpec'%(p.arg.gtype))
                self.c.write('    %s, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));'%s);
                self.c.write('\n')

        self.c.write('}\n'
                     '\n')

        self.c.write('typedef %sIface %sInterface;\n'%(i.camel_name, i.camel_name))
        self.c.write('G_DEFINE_INTERFACE (%s, %s, G_TYPE_OBJECT);\n'%(i.camel_name, i.name_lower))
        self.c.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_property_accessors(self, i):
        for p in i.properties:
            # getter
            self.c.write('/**\n'
                         ' * %s_get_%s:\n'
                         ' * @object: \n'
                         ' *\n'
                         ' * Returns: (transfer none): \n'
                         %(i.name_lower, p.name_lower))
            self.c.write(' */\n')
            self.c.write('%s\n'
                         '%s_get_%s (%s *object)\n'
                         '{\n'
                         '  %svalue;\n'%(p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in_g))
            self.c.write('  g_object_get (G_OBJECT (object), "%s", &value, NULL);\n'%(p.name_hyphen))
            if p.arg.free_func:
                self.c.write('  if (value != NULL)\n'
                             '    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-%s", (gpointer) value, (GDestroyNotify) %s);\n'
                             '  else\n'
                             '    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-%s", (gpointer) value, NULL);\n'
                             %(p.name_hyphen, p.arg.free_func, p.name_hyphen))
            self.c.write('  return value;\n')
            self.c.write('}\n')
            self.c.write('\n')
            # setter
            self.c.write('/**\n'
                         ' * %s_set_%s:\n'
                         ' * @object: \n'
                         ' * @value: \n'
                         ' *\n'
                         %(i.name_lower, p.name_lower))
            self.c.write(' */\n')
            self.c.write('void\n'
                         '%s_set_%s (%s *object, %svalue)\n'
                         '{\n'%(i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in, ))
            self.c.write('  g_object_set (G_OBJECT (object), "%s", value, NULL);\n'%(p.name_hyphen))
            self.c.write('}\n')
            self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_signal_emitters(self, i):
        for s in i.signals:
            self.c.write('void\n'
                         '%s_emit_%s (\n'
                         '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
            for a in s.args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n'
                         '  g_signal_emit_by_name (object, "%s"'%(s.name_hyphen))
            for a in s.args:
                self.c.write(', %s'%a.name)
            self.c.write(');\n')
            self.c.write('}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_method_calls(self, i):
        for m in i.methods:
            # async begin
            self.c.write('/**\n'
                         ' * %s_call_%s:\n'
                         ' * @proxy: \n'
                         %(i.name_lower, m.name_lower))
            for a in m.in_args:
                self.c.write(' * @%s: \n'%(a.name))
            self.c.write(' * @cancellable: \n'
                         ' * @callback: \n'
                         ' * @user_data: \n'
                         ' *\n')
            self.c.write(' */\n')
            self.c.write('void\n'
                         '%s_call_%s (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.in_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(',\n'
                         '    GCancellable *cancellable,\n'
                         '    GAsyncReadyCallback callback,\n'
                         '    gpointer user_data)\n'
                         '{\n')
            self.c.write('  g_dbus_proxy_call (G_DBUS_PROXY (proxy),\n'
                         '    "%s",\n'
                         '    g_variant_new ("('%(m.name))
            for a in m.in_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.in_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    cancellable,\n'
                         '    callback,\n'
                         '    user_data);\n')
            self.c.write('}\n'
                         '\n')
            # async finish
            self.c.write('/**\n'
                         ' * %s_call_%s_finish:\n'
                         ' * @proxy: \n'
                         %(i.name_lower, m.name_lower))
            for a in m.out_args:
                self.c.write(' * @out_%s: (out): \n'%(a.name))
            self.c.write(' * @res: \n'
                         ' * @error: \n'
                         ' *\n'
                         ' * Returns: \n')
            self.c.write(' */\n')
            self.c.write('gboolean\n'
                         '%s_call_%s_finish (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.out_args:
                self.c.write(',\n    %sout_%s'%(a.ctype_out, a.name))
            self.c.write(',\n'
                         '    GAsyncResult *res,\n'
                         '    GError **error)\n'
                         '{\n'
                         '  GVariant *_ret;\n'
                         '  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);\n'
                         '  if (_ret == NULL)\n'
                         '    goto _out;\n')
            self.c.write('  g_variant_get (_ret,\n'
                         '                 \"(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_out))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                 out_%s'%(a.name))
            self.c.write(');\n'
                         '  g_variant_unref (_ret);\n')
            self.c.write('_out:\n'
                         '  return _ret != NULL;\n'
                         '}\n'
                         '\n')


            # sync
            self.c.write('/**\n'
                         ' * %s_call_%s_sync:\n'
                         ' * @proxy: \n'
                         %(i.name_lower, m.name_lower))
            for a in m.in_args:
                self.c.write(' * @%s: \n'%(a.name))
            for a in m.out_args:
                self.c.write(' * @out_%s: (out): \n'%(a.name))
            self.c.write(' * @cancellable: \n'
                         ' * @error: \n'
                         ' *\n'
                         ' * Returns: \n')
            self.c.write(' */\n')
            self.c.write('gboolean\n'
                         '%s_call_%s_sync (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.in_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            for a in m.out_args:
                self.c.write(',\n    %sout_%s'%(a.ctype_out, a.name))
            self.c.write(',\n'
                         '    GCancellable *cancellable,\n'
                         '    GError **error)\n'
                         '{\n'
                         '  GVariant *_ret;\n')
            self.c.write('  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n'
                         '    "%s",\n'
                         '    g_variant_new ("('%(m.name))
            for a in m.in_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.in_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    cancellable,\n'
                         '    error);\n'
                         '  if (_ret == NULL)\n'
                         '    goto _out;\n')
            self.c.write('  g_variant_get (_ret,\n'
                         '                 \"(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_out))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                 out_%s'%(a.name))
            self.c.write(');\n'
                         '  g_variant_unref (_ret);\n')
            self.c.write('_out:\n'
                         '  return _ret != NULL;\n'
                         '}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_method_completers(self, i):
        for m in i.methods:
            self.c.write('void\n'
                         '%s_complete_%s (\n'
                         '    %s *object,\n'
                         '    GDBusMethodInvocation *invocation'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.out_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n')

            self.c.write('  g_dbus_method_invocation_return_value (invocation,\n'
                         '    g_variant_new ("(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('));\n'
                         '}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_proxy(self, i):
        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')
        self.c.write('static void\n'
                     '%s_proxy_iface_init (%sIface *iface)\n'
                     '{\n'
                     '}\n'
                     '\n'%(i.name_lower, i.camel_name))
        self.c.write('#define %s_proxy_get_type %s_proxy_get_type\n'%(i.name_lower, i.name_lower))
        self.c.write('G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n'%(i.camel_name, i.name_lower))
        self.c.write('                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init));\n'%(i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('#undef %s_proxy_get_type\n'
                     '\n'%(i.name_lower))

        # property accessors
        #
        # Note that we are guaranteed that prop_id starts at 1 and is
        # laid out in the same order as introspection data pointers
        #
        self.c.write('static void\n'
                     '%s_proxy_get_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  GValue       *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  const _ExtendedGDBusPropertyInfo *info;\n'
                         '  GVariant *variant;\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  info = _%s_property_info_pointers[prop_id - 1];\n'
                         '  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);\n'
                         '  if (info->use_gvariant)\n'
                         '    g_value_set_variant (value, variant);\n'
                         '  else\n'
                         '    g_dbus_gvariant_to_gvalue (variant, value);\n'
                         '  if (variant != NULL)\n'
                         '    g_variant_unref (variant);\n'
                         %(len(i.properties), i.name_lower))
        self.c.write('}\n'
                     '\n')
        if len(i.properties) > 0:
            self.c.write('static void\n'
                         '%s_proxy_set_property_cb (GDBusProxy *proxy,\n'
                         '  GAsyncResult *res,\n'
                         '  gpointer      user_data)\n'
                         '{\n'%(i.name_lower))
            self.c.write('  const _ExtendedGDBusPropertyInfo *info = user_data;\n'
                         '  GError *error;\n'
                         '  error = NULL;\n'
                         '  if (!g_dbus_proxy_call_finish (proxy, res, &error))\n'
                         '    {\n'
                         '      g_warning ("Error setting property `%%s\' on interface %s: %%s (%%s, %%d)",\n'
                         '                 info->parent_struct.name, \n'
                         '                 error->message, g_quark_to_string (error->domain), error->code);\n'
                         '      g_error_free (error);\n'
                         '    }\n'
                         %(i.name))
            self.c.write('}\n'
                         '\n')
        self.c.write('static void\n'
                     '%s_proxy_set_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  const GValue *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  const _ExtendedGDBusPropertyInfo *info;\n'
                         '  GVariant *variant;\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  info = _%s_property_info_pointers[prop_id - 1];\n'
                         '  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));\n'
                         '  g_dbus_proxy_call (G_DBUS_PROXY (object),\n'
                         '    "org.freedesktop.DBus.Properties.Set",\n'
                         '    g_variant_new ("(ssv)", "%s", info->parent_struct.name, variant),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    NULL, (GAsyncReadyCallback) %s_proxy_set_property_cb, (gpointer) info);\n'
                         '  g_variant_unref (variant);\n'
                         %(len(i.properties), i.name_lower, i.name, i.name_lower))
        self.c.write('}\n'
                     '\n')

        # signal received
        self.c.write('static void\n'
                     '%s_proxy_g_signal (GDBusProxy *proxy,\n'
                     '  const gchar *sender_name,\n'
                     '  const gchar *signal_name,\n'
                     '  GVariant *parameters)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  _ExtendedGDBusSignalInfo *info;\n'
                     '  GVariantIter iter;\n'
                     '  GVariant *child;\n'
                     '  GValue *paramv;\n'
                     '  guint num_params;\n'
                     '  guint n;\n'
                     '  guint signal_id;\n');
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.c.write('  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_%s_interface_info, signal_name);\n'
                     '  if (info == NULL)\n'
                     '    return;\n'
                     %(i.name_lower))
        self.c.write ('  num_params = g_variant_n_children (parameters);\n'
                      '  paramv = g_new0 (GValue, num_params + 1);\n'
                      '  g_value_init (&paramv[0], %sTYPE_%s);\n'
                      '  g_value_set_object (&paramv[0], proxy);\n'
                      %(i.ns_upper, i.name_upper))
        self.c.write('  g_variant_iter_init (&iter, parameters);\n'
                     '  n = 1;\n'
                     '  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n'
                     '    {\n'
                     '      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];\n'
                     '      if (arg_info->use_gvariant)\n'
                     '        {\n'
                     '          g_value_init (&paramv[n], G_TYPE_VARIANT);\n'
                     '          g_value_set_variant (&paramv[n], child);\n'
                     '          n++;\n'
                     '        }\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n'
                     '      g_variant_unref (child);\n'
                     '    }\n'
                     )
        self.c.write('  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n'
                     %(i.ns_upper, i.name_upper))
        self.c.write('  g_signal_emitv (paramv, signal_id, 0, NULL);\n')
        self.c.write('  for (n = 0; n < num_params + 1; n++)\n'
                     '    g_value_unset (&paramv[n]);\n'
                     '  g_free (paramv);\n')
        self.c.write('}\n'
                     '\n')

        # property changed
        self.c.write('static void\n'
                     '%s_proxy_g_properties_changed (GDBusProxy *proxy,\n'
                     '  GVariant *changed_properties,\n'
                     '  const gchar *const *invalidated_properties)\n'
                     '{\n'%(i.name_lower))
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.c.write('  guint n;\n'
                     '  const gchar *key;\n'
                     '  GVariantIter *iter;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  g_variant_get (changed_properties, "a{sv}", &iter);\n'
                     '  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))\n'
                     '    {\n'
                     '      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, key);\n'
                     '      if (info != NULL)\n'
                     '        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n'
                     '    }\n'
                     '  g_variant_iter_free (iter);\n'
                     '  for (n = 0; invalidated_properties[n] != NULL; n++)\n'
                     '    {\n'
                     '      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, invalidated_properties[n]);\n'
                     '      if (info != NULL)\n'
                     '        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n'
                     '    }\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.name_lower))

        # class boilerplate
        self.c.write('static void\n'
                     '%s_proxy_init (%sProxy *proxy)\n'
                     '{\n'
                     '  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), %s_interface_info ());\n'
                     '}\n'
                     '\n'%(i.name_lower, i.camel_name, i.name_lower))
        self.c.write('static void\n'
                     '%s_proxy_class_init (%sProxyClass *klass)\n'
                     '{\n'
                     '  GObjectClass *gobject_class;\n'
                     '  GDBusProxyClass *proxy_class;\n'
                     '\n'
                     '  gobject_class = G_OBJECT_CLASS (klass);\n'
                     '  gobject_class->get_property = %s_proxy_get_property;\n'
                     '  gobject_class->set_property = %s_proxy_set_property;\n'
                     '\n'
                     '  proxy_class = G_DBUS_PROXY_CLASS (klass);\n'
                     '  proxy_class->g_signal = %s_proxy_g_signal;\n'
                     '  proxy_class->g_properties_changed = %s_proxy_g_properties_changed;\n'
                     '\n'%(i.name_lower, i.camel_name, i.name_lower, i.name_lower, i.name_lower, i.name_lower))
        if len(i.properties) > 0:
            self.c.write('\n'
                         '  %s_override_properties (gobject_class, 1);\n'%(i.name_lower))
        self.c.write('}\n')

        # constructors
        self.c.write('/**\n'
                     ' * %s_proxy_new:\n'
                     ' * @connection: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @callback: \n'
                     ' * @user_data: \n'
                     ' *\n'
                     %(i.name_lower))
        self.c.write(' */\n')
        self.c.write('void\n'
                     '%s_proxy_new (\n'
                     '    GDBusConnection     *connection,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GAsyncReadyCallback  callback,\n'
                     '    gpointer             user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.ns_upper, i.name_upper, i.name))
        self.c.write('/**\n'
                     ' * %s_proxy_new_finish:\n'
                     ' * @res: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sProxy):\n'
                     %(i.name_lower, i.camel_name))
        self.c.write(' */\n')
        self.c.write('%s *\n'
                     '%s_proxy_new_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper))
        self.c.write('/**\n'
                     ' * %s_proxy_new_sync:\n'
                     ' * @connection: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sProxy):\n'
                     %(i.name_lower, i.camel_name))
        self.c.write(' */\n')
        self.c.write('%s *\n'
                     '%s_proxy_new_sync (\n'
                     '    GDBusConnection     *connection,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
        self.c.write('\n')
        self.c.write('/**\n'
                     ' * %s_proxy_new_for_bus:\n'
                     ' * @bus_type: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @callback: \n'
                     ' * @user_data: \n'
                     ' *\n'
                     %(i.name_lower))
        self.c.write(' */\n')
        self.c.write('void\n'
                     '%s_proxy_new_for_bus (\n'
                     '    GBusType             bus_type,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GAsyncReadyCallback  callback,\n'
                     '    gpointer             user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.ns_upper, i.name_upper, i.name))
        self.c.write('/**\n'
                     ' * %s_proxy_new_for_bus_finish:\n'
                     ' * @res: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sProxy):\n'
                     %(i.name_lower, i.camel_name))
        self.c.write(' */\n')
        self.c.write('%s *\n'
                     '%s_proxy_new_for_bus_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper))
        self.c.write('/**\n'
                     ' * %s_proxy_new_for_bus_sync:\n'
                     ' * @bus_type: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sProxy):\n'
                     %(i.name_lower, i.camel_name))
        self.c.write(' */\n')
        self.c.write('%s *\n'
                     '%s_proxy_new_for_bus_sync (\n'
                     '    GBusType             bus_type,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
        self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_skeleton(self, i):
        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')

        self.c.write('struct _%sSkeletonPrivate\n'
                     '{\n'
                     '  GValueArray *properties;\n'
                     '  GList *changed_properties;\n'
                     '  GSource *changed_properties_idle_source;\n'
                     '  GMainContext *context;\n'
                     '};\n'
                     '\n'%i.camel_name)

        self.c.write('static void\n'
                     '_%s_skeleton_handle_method_call (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *method_name,\n'
                     '  GVariant *parameters,\n'
                     '  GDBusMethodInvocation *invocation,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n'
                     '  _ExtendedGDBusMethodInfo *info;\n'
                     '  GVariantIter iter;\n'
                     '  GVariant *child;\n'
                     '  GValue *paramv;\n'
                     '  guint num_params;\n'
                     '  guint n;\n'
                     '  guint signal_id;\n'
                     '  GValue return_value = {0};\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);\n'
                     '  g_assert (info != NULL);\n'
                     %())
        self.c.write ('  num_params = g_variant_n_children (parameters);\n'
                      '  paramv = g_new0 (GValue, num_params + 2);\n'
                      '  g_value_init (&paramv[0], %sTYPE_%s);\n'
                      '  g_value_set_object (&paramv[0], skeleton);\n'
                      '  g_value_init (&paramv[1], G_TYPE_DBUS_METHOD_INVOCATION);\n'
                      '  g_value_set_object (&paramv[1], invocation);\n'
                      %(i.ns_upper, i.name_upper))
        self.c.write('  g_variant_iter_init (&iter, parameters);\n'
                     '  n = 2;\n'
                     '  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n'
                     '    {\n'
                     '      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - 2];\n'
                     '      if (arg_info->use_gvariant)\n'
                     '        {\n'
                     '          g_value_init (&paramv[n], G_TYPE_VARIANT);\n'
                     '          g_value_set_variant (&paramv[n], child);\n'
                     '          n++;\n'
                     '        }\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n'
                     '      g_variant_unref (child);\n'
                     '    }\n'
                     )
        self.c.write('  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n'
                     %(i.ns_upper, i.name_upper))
        self.c.write('  g_value_init (&return_value, G_TYPE_BOOLEAN);\n'
                     '  g_signal_emitv (paramv, signal_id, 0, &return_value);\n'
                     '  if (!g_value_get_boolean (&return_value))\n'
                     '    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);\n'
                     '  g_value_unset (&return_value);\n'
                     )
        self.c.write('  for (n = 0; n < num_params + 2; n++)\n'
                     '    g_value_unset (&paramv[n]);\n'
                     '  g_free (paramv);\n')
        self.c.write('}\n'
                     '\n')

        self.c.write('static GVariant *\n'
                     '_%s_skeleton_handle_get_property (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *property_name,\n'
                     '  GError **error,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n'
                     '  GValue value = {0};\n'
                     '  GParamSpec *pspec;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  GVariant *ret;\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  ret = NULL;\n'
                     '  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, property_name);\n'
                     '  g_assert (info != NULL);\n'
                     '  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n'
                     '  if (pspec == NULL)\n'
                     '    {\n'
                     '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
                     '    }\n'
                     '  else\n'
                     '    {\n'
                     '      g_value_init (&value, pspec->value_type);\n'
                     '      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n'
                     '      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));\n'
                     '      g_value_unset (&value);\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n'
                     %(i.name_lower))

        self.c.write('static gboolean\n'
                     '_%s_skeleton_handle_set_property (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *property_name,\n'
                     '  GVariant *variant,\n'
                     '  GError **error,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n'
                     '  GValue value = {0};\n'
                     '  GParamSpec *pspec;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  gboolean ret;\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  ret = FALSE;\n'
                     '  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, property_name);\n'
                     '  g_assert (info != NULL);\n'
                     '  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n'
                     '  if (pspec == NULL)\n'
                     '    {\n'
                     '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
                     '    }\n'
                     '  else\n'
                     '    {\n'
                     '      if (info->use_gvariant)\n'
                     '        g_value_set_variant (&value, variant);\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (variant, &value);\n'
                     '      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n'
                     '      g_value_unset (&value);\n'
                     '      ret = TRUE;\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n'
                     %(i.name_lower))


        self.c.write('static const GDBusInterfaceVTable _%s_skeleton_vtable =\n'
                     '{\n'
                     '  _%s_skeleton_handle_method_call,\n'
                     '  _%s_skeleton_handle_get_property,\n'
                     '  _%s_skeleton_handle_set_property\n'
                     '};\n'
                     '\n'%(i.name_lower, i.name_lower, i.name_lower, i.name_lower))

        self.c.write('static GDBusInterfaceInfo *\n'
                     '%s_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)\n'
                     '{\n'
                     '  return %s_interface_info ();\n'
                     %(i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static GDBusInterfaceVTable *\n'
                     '%s_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)\n'
                     '{\n'
                     '  return (GDBusInterfaceVTable *) &_%s_skeleton_vtable;\n'
                     %(i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static GVariant *\n'
                     '%s_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)\n'
                     '{\n'
                     '  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('\n'
                     '  GVariantBuilder builder;\n'
                     '  guint n;\n'
                     '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                     '  if (_%s_interface_info.properties == NULL)\n'
                     '    goto out;\n'
                     '  for (n = 0; _%s_interface_info.properties[n] != NULL; n++)\n'
                     '    {\n'
                     '      GDBusPropertyInfo *info = _%s_interface_info.properties[n];\n'
                     '      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n'
                     '        {\n'
                     '          GVariant *value;\n'
                     '          value = _%s_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", info->name, NULL, skeleton);\n'
                     '          if (value != NULL)\n'
                     '            {\n'
                     '              if (g_variant_is_floating (value))\n'
                     '                g_variant_ref_sink (value);\n'
                     '              g_variant_builder_add (&builder, "{sv}", info->name, value);\n'
                     '              g_variant_unref (value);\n'
                     '            }\n'
                     '        }\n'
                     '    }\n'
                     'out:\n'
                     '  return g_variant_builder_end (&builder);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.name_lower, i.name_lower, i.name_lower, i.name))

        if len(i.properties) > 0:
            self.c.write('static gboolean _%s_emit_changed (gpointer user_data);\n'
                         '\n'
                         %(i.name_lower))

        self.c.write('static void\n'
                     '%s_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)\n'
                     '{\n'
                     %(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n'
                         '  if (skeleton->priv->changed_properties_idle_source != NULL)\n'
                         '    {\n'
                         '      g_source_destroy (skeleton->priv->changed_properties_idle_source);\n'
                         '      skeleton->priv->changed_properties_idle_source = NULL;\n'
                         '      _%s_emit_changed (skeleton);\n'
                         '    }\n'
                         %(i.camel_name, i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('}\n'
                     '\n')

        for s in i.signals:
            self.c.write('static void\n'
                         '_%s_on_signal_%s (\n'
                         '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
            for a in s.args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n'
                         '  %sSkeleton *skeleton = %s%s_SKELETON (object);\n'
                         '  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));\n'
                         %(i.camel_name, i.ns_upper, i.name_upper))
            self.c.write('  if (connection == NULL)\n'
                         '    return;\n'
                         '  g_dbus_connection_emit_signal (connection,\n'
                         '    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", "%s",\n'
                         '    g_variant_new ("('
                         %(i.name, s.name))
            for a in s.args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in s.args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('), NULL);\n')
            self.c.write('}\n'
                         '\n')

        self.c.write('static void\n'
                     '%s_skeleton_iface_init (%sIface *iface)\n'
                     '{\n'
                     %(i.name_lower, i.camel_name))
        for s in i.signals:
            self.c.write('  iface->%s = _%s_on_signal_%s;\n'
                         %(s.name_lower, i.name_lower, s.name_lower))
        self.c.write('}\n'
                     '\n')
        self.c.write('#define %s_skeleton_get_type %s_skeleton_get_type\n'%(i.name_lower, i.name_lower))
        self.c.write('G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,\n'%(i.camel_name, i.name_lower))
        self.c.write('                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init));\n'%(i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('#undef %s_skeleton_get_type\n'
                     '\n'%(i.name_lower))

        # finalize
        self.c.write('static void\n'
                     '%s_skeleton_finalize (GObject *object)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  %sSkeleton *skeleton = %s%s_SKELETON (object);\n'%(i.camel_name, i.ns_upper, i.name_upper))
        if len(i.properties) > 0:
            self.c.write('  g_value_array_free (skeleton->priv->properties);\n')
        self.c.write('  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
        self.c.write('  g_list_free (skeleton->priv->changed_properties);\n')
        self.c.write('  if (skeleton->priv->changed_properties_idle_source != NULL)\n')
        self.c.write('    g_source_destroy (skeleton->priv->changed_properties_idle_source);\n')
        self.c.write('  if (skeleton->priv->context != NULL)\n')
        self.c.write('    g_main_context_unref (skeleton->priv->context);\n')
        self.c.write('  G_OBJECT_CLASS (%s_skeleton_parent_class)->finalize (object);\n'
                     '}\n'
                     '\n'%(i.name_lower))

        # property accessors (TODO: generate PropertiesChanged signals in setter)
        self.c.write('static void\n'
                     '%s_skeleton_get_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  GValue       *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  %sSkeleton *skeleton = %s%s_SKELETON (object);\n'
                     '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                     '  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);\n'
                     %(i.camel_name, i.ns_upper, i.name_upper, len(i.properties)))
        self.c.write('}\n'
                     '\n')
        if len(i.properties) > 0:
            # if property is already scheduled then re-use entry.. though it could be
            # that the user did
            #
            #  foo_set_prop_bar (object, "");
            #  foo_set_prop_bar (object, "blah");
            #
            # say, every update... In this case, where nothing happens, we obviously
            # don't want a PropertiesChanged() event. We can easily check for this
            # by comparing against the _original value_ recorded before the first
            # change event. If the latest value is not different from the original
            # one, we can simply ignore the ChangedProperty
            #
            self.c.write('static gboolean\n'
                         '_%s_emit_changed (gpointer user_data)\n'
                         '{\n'
                         '  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n'
                         %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
            self.c.write('  GList *l;\n'
                         '  GVariantBuilder builder;\n'
                         '  GVariantBuilder invalidated_builder;\n'
                         '  guint num_changes;\n'
                         '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                         '  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));\n'
                         '  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)\n'
                         '    {\n'
                         '      ChangedProperty *cp = l->data;\n'
                         '      GVariant *variant;\n'
                         '      const GValue *cur_value;\n'
                         '\n'
                         '      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];\n'
                         '      if (!_g_value_equal (cur_value, &cp->orig_value))\n'
                         '        {\n'
                         '          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));\n'
                         '          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);\n'
                         '          g_variant_unref (variant);\n'
                         '          num_changes++;\n'
                         '        }\n'
                         '    }\n'
                         '  if (num_changes > 0)\n'
                         '    {\n'
                         '      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),\n'
                         '                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),\n'
                         '                                     "org.freedesktop.DBus.Properties",\n'
                         '                                     "PropertiesChanged",\n'
                         '                                     g_variant_new ("(sa{sv}as)",\n'
                         '                                                    "%s",\n'
                         '                                                    &builder, &invalidated_builder),\n'
                         '                                     NULL);\n'
                         '    }\n'
                         '  else\n'
                         '    {\n'
                         '      g_variant_builder_clear (&builder);\n'
                         '      g_variant_builder_clear (&invalidated_builder);\n'
                         '    }\n'
                         %(i.name))
            self.c.write('  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
            self.c.write('  g_list_free (skeleton->priv->changed_properties);\n')
            self.c.write('  skeleton->priv->changed_properties = NULL;\n')
            self.c.write('  skeleton->priv->changed_properties_idle_source = NULL;\n')
            self.c.write('  return FALSE;\n'
                         '}\n'
                         '\n')
            self.c.write('static void\n'
                         '_%s_schedule_emit_changed (%sSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)\n'
                         '{\n'
                         '  ChangedProperty *cp;\n'
                         '  GList *l;\n'
                         '  cp = NULL;\n'
                         '  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)\n'
                         '    {\n'
                         '      ChangedProperty *i_cp = l->data;\n'
                         '      if (i_cp->info == info)\n'
                         '        {\n'
                         '          cp = i_cp;\n'
                         '          break;\n'
                         '        }\n'
                         '    }\n'
                         %(i.name_lower, i.camel_name))
            self.c.write('  if (cp == NULL)\n'
                         '    {\n'
                         '      cp = g_new0 (ChangedProperty, 1);\n'
                         '      cp->prop_id = prop_id;\n'
                         '      cp->info = info;\n'
                         '      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);\n'
                         '      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));\n'
                         '      g_value_copy (orig_value, &cp->orig_value);\n'
                         '    }\n'
                         '  if (skeleton->priv->changed_properties_idle_source == NULL)\n'
                         '    {\n'
                         '      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();\n'
                         '      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);\n'
                         '      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _%s_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);\n'
                         '      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);\n'
                         '      g_source_unref (skeleton->priv->changed_properties_idle_source);\n'
                         '    }\n'
                         '}\n'
                         '\n'
                         %(i.name_lower))
        self.c.write('static void\n'
                     '%s_skeleton_set_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  const GValue *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  %sSkeleton *skeleton = %s%s_SKELETON (object);\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))\n'
                         '    {\n'
                         '      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)\n'
                         '        _%s_schedule_emit_changed (skeleton, _%s_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);\n'
                         '      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);\n'
                         '      g_object_notify_by_pspec (object, pspec);\n'
                         '    }\n'
                         %(i.camel_name, i.ns_upper, i.name_upper, len(i.properties), i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static void\n'
                     '%s_skeleton_init (%sSkeleton *skeleton)\n'
                     '{\n'
                     '  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, %sTYPE_%s_SKELETON, %sSkeletonPrivate);\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper, i.camel_name))
        self.c.write('  skeleton->priv->context = g_main_context_get_thread_default ();\n')
        self.c.write('  if (skeleton->priv->context != NULL)\n')
        self.c.write('    g_main_context_ref (skeleton->priv->context);\n')
        if len(i.properties) > 0:
            self.c.write('  skeleton->priv->properties = g_value_array_new (%d);\n'%(len(i.properties)))
            n = 0
            for p in i.properties:
                self.c.write('  g_value_array_append (skeleton->priv->properties, NULL);\n')
                self.c.write('  g_value_init (&skeleton->priv->properties->values[%d], %s);\n'%(n, p.arg.gtype))
                n += 1
        self.c.write('}\n'
                     '\n')
        self.c.write('static void\n'
                     '%s_skeleton_class_init (%sSkeletonClass *klass)\n'
                     '{\n'
                     '  GObjectClass *gobject_class;\n'
                     '  GDBusInterfaceSkeletonClass *skeleton_class;\n'
                     '\n'
                     '  g_type_class_add_private (klass, sizeof (%sSkeletonPrivate));\n'
                     '\n'
                     '  gobject_class = G_OBJECT_CLASS (klass);\n'
                     '  gobject_class->finalize = %s_skeleton_finalize;\n'
                     '  gobject_class->get_property = %s_skeleton_get_property;\n'
                     '  gobject_class->set_property = %s_skeleton_set_property;\n'
                     '\n'%(i.name_lower, i.camel_name, i.camel_name, i.name_lower, i.name_lower, i.name_lower))
        if len(i.properties) > 0:
            self.c.write('\n'
                         '  %s_override_properties (gobject_class, 1);\n'%(i.name_lower))
        self.c.write('\n'
                     '  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);\n');
        self.c.write('  skeleton_class->get_info = %s_skeleton_dbus_interface_get_info;\n'%(i.name_lower))
        self.c.write('  skeleton_class->get_properties = %s_skeleton_dbus_interface_get_properties;\n'%(i.name_lower))
        self.c.write('  skeleton_class->flush = %s_skeleton_dbus_interface_flush;\n'%(i.name_lower))
        self.c.write('  skeleton_class->get_vtable = %s_skeleton_dbus_interface_get_vtable;\n'%(i.name_lower))
        self.c.write('}\n'
                     '\n')

        # constructors
        self.c.write('/**\n'
                     ' * %s_skeleton_new:\n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sSkeleton):\n'
                     %(i.name_lower, i.camel_name))
        self.c.write(' */\n')
        self.c.write('%s *\n'
                     '%s_skeleton_new (void)\n'
                     '{\n'
                     '  return %s%s (g_object_new (%sTYPE_%s_SKELETON, NULL));\n'
                     '}\n'
                     '\n'%(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))

    # ---------------------------------------------------------------------------------------------------

    def generate_object_manager_client(self):
        self.c.write('/* ------------------------------------------------------------------------\n'
                     ' * Code for proxy manager\n'
                     ' * ------------------------------------------------------------------------\n'
                     ' */\n'
                     '\n')

        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')
        self.c.write('#define %sobject_manager_client_get_type %sobject_manager_client_get_type\n'%(self.ns_lower, self.ns_lower))
        self.c.write('G_DEFINE_TYPE (%sObjectManagerClient, %sobject_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);\n'%(self.namespace, self.ns_lower))
        self.c.write('#undef %sobject_manager_client_get_type\n'
                     '\n'%(self.ns_lower))

        # class boilerplate
        self.c.write('static void\n'
                     '%sobject_manager_client_init (%sObjectManagerClient *manager)\n'
                     '{\n'
                     '}\n'
                     '\n'%(self.ns_lower, self.namespace))
        self.c.write('static void\n'
                     '%sobject_manager_client_class_init (%sObjectManagerClientClass *klass)\n'
                     '{\n'
                     '}\n'
                     '\n'%(self.ns_lower, self.namespace))

        self.c.write('GType\n'
                     '%sobject_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data)\n'
                     '{\n'
                     %(self.ns_lower))
        self.c.write('  static gsize once_init_value = 0;\n'
                     '  static GHashTable *lookup_hash;\n'
                     '  GType ret;\n'
                     '\n'
                     '  if (g_once_init_enter (&once_init_value))\n'
                     '    {\n'
                     '      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);\n')
        for i in self.ifaces:
            self.c.write('      g_hash_table_insert (lookup_hash, "%s", GSIZE_TO_POINTER (%sTYPE_%s_PROXY));\n'
                         %(i.name, i.ns_upper, i.name_upper))
        self.c.write('      g_once_init_leave (&once_init_value, 1);\n'
                     '    }\n')
        self.c.write('  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));\n'
                     '  if (ret == (GType) 0)\n'
                     '    ret = G_TYPE_DBUS_PROXY;\n')
        self.c.write('  return ret;\n'
                     '}\n'
                     '\n')

        # constructors
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new:\n'
                     ' * @connection: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @callback: \n'
                     ' * @user_data: \n'
                     ' *\n'
                     %(self.ns_lower))
        self.c.write(' */\n')
        self.c.write('void\n'
                     '%sobject_manager_client_new (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new_finish:\n'
                     ' * @res: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sObjectManagerClient):\n'
                     %(self.ns_lower, self.namespace))
        self.c.write(' */\n')
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower))
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new_sync:\n'
                     ' * @connection: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sObjectManagerClient):\n'
                     %(self.ns_lower, self.namespace))
        self.c.write(' */\n')
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_sync (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('\n')
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new_for_bus:\n'
                     ' * @bus_type: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @callback: \n'
                     ' * @user_data: \n'
                     ' *\n'
                     %(self.ns_lower))
        self.c.write(' */\n')
        self.c.write('void\n'
                     '%sobject_manager_client_new_for_bus (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new_for_bus_finish:\n'
                     ' * @res: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sObjectManagerClient):\n'
                     %(self.ns_lower, self.namespace))
        self.c.write(' */\n')
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_for_bus_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower))
        self.c.write('/**\n'
                     ' * %sobject_manager_client_new_for_bus_sync:\n'
                     ' * @bus_type: \n'
                     ' * @flags: \n'
                     ' * @name: \n'
                     ' * @object_path: \n'
                     ' * @cancellable: \n'
                     ' * @error: \n'
                     ' *\n'
                     ' * Returns: (transfer full) (type %sObjectManagerClient):\n'
                     %(self.ns_lower, self.namespace))
        self.c.write(' */\n')
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_for_bus_sync (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_intro()
        self.declare_types()
        for i in self.ifaces:
            self.c.write('/* ------------------------------------------------------------------------\n'
                         ' * Code for interface %s\n'
                         ' * ------------------------------------------------------------------------\n'
                         ' */\n'
                         '\n'%(i.name))
            self.generate_introspection_for_interface(i)
            self.generate_interface(i)
            self.generate_property_accessors(i)
            self.generate_signal_emitters(i)
            self.generate_method_calls(i)
            self.generate_method_completers(i)
            self.generate_proxy(i)
            self.generate_skeleton(i)
        if self.generate_objmanager:
            self.generate_object_manager_client()
        self.generate_outro()
