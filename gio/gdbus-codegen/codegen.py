# -*- Mode: Python -*-

import sys
import argparse

import config
import utils
import dbustypes

# ----------------------------------------------------------------------------------------------------

class CodeGenerator:
    def __init__(self, ifaces, namespace, interface_prefix, h, c):
        self.ifaces = ifaces
        self.h = h
        self.c = c
        self.namespace = namespace
        if len(namespace) > 1:
            self.ns_upper = utils.camel_case_to_uscore(namespace).upper() + '_'
            self.ns_lower = utils.camel_case_to_uscore(namespace).lower() + '_'
        else:
            self.ns_upper = ''
            self.ns_lower = ''
        self.interface_prefix = interface_prefix
        self.header_guard = self.h.name.upper().replace('.', '_').replace('-', '_')

    # ----------------------------------------------------------------------------------------------------

    def generate_intro(self):
        self.c.write('/*\n'
                     ' * Generated by gdbus-codegen.py %s. DO NOT EDIT.\n'
                     ' */\n'
                     '\n'
                     %(config.VERSION))
        self.c.write('#ifdef HAVE_CONFIG_H\n'
                     '#  include "config.h"\n'
                     '#endif\n'
                     '\n'
                     '#include "%s"\n'
                     '\n'%(self.h.name))

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusArgInfo parent_struct;\n'
                     '  gboolean use_gvariant;\n'
                     '} _ExtendedGDBusArgInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusMethodInfo parent_struct;\n'
                     '  const gchar *signal_name;\n'
                     '} _ExtendedGDBusMethodInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusSignalInfo parent_struct;\n'
                     '  const gchar *signal_name;\n'
                     '} _ExtendedGDBusSignalInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  GDBusPropertyInfo parent_struct;\n'
                     '  const gchar *hyphen_name;\n'
                     '  gboolean use_gvariant;\n'
                     '} _ExtendedGDBusPropertyInfo;\n'
                     '\n')

        self.c.write('typedef struct\n'
                     '{\n'
                     '  const _ExtendedGDBusPropertyInfo *info;\n'
                     '  GParamSpec *pspec;\n'
                     '  GValue value;\n'
                     '} ChangedProperty;\n'
                     '\n'
                     'static void\n'
                     '_changed_property_free (ChangedProperty *data)\n'
                     '{\n'
                     '  g_value_unset (&data->value);\n'
                     '  g_free (data);\n'
                     '}\n'
                     '\n')

        self.c.write('static gboolean\n'
                     '_g_strv_equal0 (gchar **a, gchar **b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  guint n;\n'
                     '  if (a == NULL && b == NULL)\n'
                     '    {\n'
                     '      ret = TRUE;\n'
                     '      goto out;\n'
                     '    }\n'
                     '  if (a == NULL || b == NULL)\n'
                     '    goto out;\n'
                     '  if (g_strv_length (a) != g_strv_length (b))\n'
                     '    goto out;\n'
                     '  for (n = 0; a[n] != NULL; n++)\n'
                     '    if (g_strcmp0 (a[n], b[n]) != 0)\n'
                     '      goto out;\n'
                     '  ret = TRUE;\n'
                     'out:\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        self.c.write('static gboolean\n'
                     '_g_variant_equal0 (GVariant *a, GVariant *b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  if (a == NULL && b == NULL)\n'
                     '    goto out;\n'
                     '  if (a == NULL || b == NULL)\n'
                     '    goto out;\n'
                     '  ret = g_variant_equal (a, b);\n'
                     'out:\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        # simplified - only supports the types we use
        self.c.write('static gboolean\n'
                     '_g_value_equal (const GValue *a, const GValue *b)\n'
                     '{\n'
                     '  gboolean ret = FALSE;\n'
                     '  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));\n'
                     '  switch (G_VALUE_TYPE (a))\n'
                     '    {\n'
                     '      case G_TYPE_BOOLEAN:\n'
                     '        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UCHAR:\n'
                     '        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));\n'
                     '        break;\n'
                     '      case G_TYPE_INT:\n'
                     '        ret = (g_value_get_int (a) == g_value_get_int (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UINT:\n'
                     '        ret = (g_value_get_uint (a) == g_value_get_uint (b));\n'
                     '        break;\n'
                     '      case G_TYPE_INT64:\n'
                     '        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));\n'
                     '        break;\n'
                     '      case G_TYPE_UINT64:\n'
                     '        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));\n'
                     '        break;\n'
                     '      case G_TYPE_DOUBLE:\n'
                     '        ret = (g_value_get_double (a) == g_value_get_double (b));\n'
                     '        break;\n'
                     '      case G_TYPE_STRING:\n'
                     '        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);\n'
                     '        break;\n'
                     '      case G_TYPE_VARIANT:\n'
                     '        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));\n'
                     '        break;\n'
                     '      default:\n'
                     '        if (G_VALUE_TYPE (a) == G_TYPE_STRV)\n'
                     '          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));\n'
                     '        else\n'
                     '          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));\n'
                     '        break;\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n')

        self.h.write('/*\n'
                     ' * Generated by gdbus-codegen.py %s. DO NOT EDIT.\n'
                     ' */\n'
                     '\n'
                     '#ifndef __%s__\n'
                     '#define __%s__\n'
                     '\n'%(config.VERSION, self.header_guard, self.header_guard))
        self.h.write('#include <gio/gio.h>\n'
                     '\n'
                     'G_BEGIN_DECLS\n'
                     '\n')

    # ----------------------------------------------------------------------------------------------------

    def declare_types(self):
        for i in self.ifaces:
            self.h.write('\n')
            self.h.write('/* ------------------------------------------------------------------------ */\n')
            self.h.write('/* Declarations for %s */\n'%i.name)
            self.h.write('\n')

            # First the GInterface
            self.h.write('#define %sTYPE_%s (%s_get_gtype ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s, %s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %s%s_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_%s, %s))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%s;\n'%(i.camel_name))
            self.h.write('typedef struct _%s %s;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sIface %sIface;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sIface\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GTypeInterface parent_iface;\n')
            if len(i.methods) > 0:
                self.h.write('\n')
                self.h.write('  /* GObject signal class handlers for incoming D-Bus method calls: */\n')
                for m in i.methods:
                    self.h.write('  gboolean (*handle_%s) (\n'
                                 '    %s *object,\n'
                                 '    GDBusMethodInvocation *invocation'%(m.name_lower, i.camel_name))
                    for a in m.in_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
            if len(i.signals) > 0:
                self.h.write('\n')
                self.h.write('  /* GObject signal class handlers for received D-Bus signals: */\n')
                for s in i.signals:
                    self.h.write('  void (*%s) (\n'
                                 '    %s *object'%(s.name_lower, i.camel_name))
                    for a in s.args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_get_gtype (void) G_GNUC_CONST;\n'%(i.name_lower))
            self.h.write('\n')
            self.h.write('GDBusInterfaceInfo *%s_interface_info (void);\n'%(i.name_lower))
            if len(i.properties) > 0:
                self.h.write('guint %s_override_properties (GObjectClass *klass, guint property_id_begin);\n'%(i.name_lower))
            self.h.write('\n')

            # Then method call completion functions
            if len(i.methods) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus method call completion functions: */\n')
                for m in i.methods:
                    self.h.write('void %s_complete_%s (\n'
                                 '    %s *object,\n'
                                 '    GDBusMethodInvocation *invocation'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.out_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then signal emission functions
            if len(i.signals) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus signal emissions functions: */\n')
                for s in i.signals:
                    self.h.write('void %s_emit_%s (\n'
                                 '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
                    for a in s.args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(');\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then method call declarations
            if len(i.methods) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus method calls: */\n')
                for m in i.methods:
                    # async begin
                    self.h.write('void %s_call_%s (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.in_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    self.h.write(',\n'
                                 '    GCancellable *cancellable,\n'
                                 '    GAsyncReadyCallback callback,\n'
                                 '    gpointer user_data);\n')
                    self.h.write('\n')
                    # async finish
                    self.h.write('gboolean %s_call_%s_finish (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.out_args:
                        self.h.write(',\n    %sout_%s'%(a.ctype_out, a.name))
                    self.h.write(',\n'
                                 '    GAsyncResult *res,\n'
                                 '    GError **error);\n')
                    self.h.write('\n')
                    # sync
                    self.h.write('gboolean %s_call_%s_sync (\n'
                                 '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
                    for a in m.in_args:
                        self.h.write(',\n    %s%s'%(a.ctype_in, a.name))
                    for a in m.out_args:
                        self.h.write(',\n    %sout_%s'%(a.ctype_out, a.name))
                    self.h.write(',\n'
                                 '    GCancellable *cancellable,\n'
                                 '    GError **error);\n')
                    self.h.write('\n')
                self.h.write('\n')

            # Then the property accessor declarations
            if len(i.properties) > 0:
                self.h.write('\n')
                self.h.write('/* D-Bus property accessors: */\n')
                for p in i.properties:
                    # getter
                    self.h.write('%s%s_get_%s (%s *object);\n'%(p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name))
                    # setter
                    self.h.write('void %s_set_%s (%s *object, %svalue);\n'%(i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in, ))
                    self.h.write('\n')

            # Then the proxy
            self.h.write('\n')
            self.h.write('/* ---- */\n')
            self.h.write('\n')
            self.h.write('#define %sTYPE_%s_PROXY (%s_proxy_get_gtype ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_PROXY, %sProxy))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_PROXY, %sProxyClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_PROXY, %sProxyClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_PROXY))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %sIS_%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_PROXY))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('\n')
            self.h.write('typedef struct _%sProxy %sProxy;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sProxyClass %sProxyClass;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sProxyPrivate %sProxyPrivate;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sProxy\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusProxy parent_instance;\n')
            self.h.write('  %sProxyPrivate *priv;\n'%(i.camel_name))
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('struct _%sProxyClass\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusProxyClass parent_class;\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_proxy_get_gtype (void) G_GNUC_CONST;\n'%(i.name_lower))

            self.h.write('\n')
            self.h.write('void %s_proxy_new (\n'
                         '    GDBusConnection     *connection,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GAsyncReadyCallback  callback,\n'
                         '    gpointer             user_data);\n'
                         %(i.name_lower))
            self.h.write('%s *%s_proxy_new_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('%s *%s_proxy_new_sync (\n'
                         '    GDBusConnection     *connection,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('\n')
            self.h.write('void %s_proxy_new_for_bus (\n'
                         '    GBusType             bus_type,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GAsyncReadyCallback  callback,\n'
                         '    gpointer             user_data);\n'
                         %(i.name_lower))
            self.h.write('%s *%s_proxy_new_for_bus_finish (\n'
                         '    GAsyncResult        *res,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('%s *%s_proxy_new_for_bus_sync (\n'
                         '    GBusType             bus_type,\n'
                         '    GDBusProxyFlags      flags,\n'
                         '    const gchar         *name,\n'
                         '    const gchar         *object_path,\n'
                         '    GCancellable        *cancellable,\n'
                         '    GError             **error);\n'
                         %(i.camel_name, i.name_lower))
            self.h.write('\n')

            # Interface proxy accessors
            self.h.write('#define %sGET_%s(object) (g_dbus_object_lookup_with_typecheck (G_DBUS_OBJECT (object), "%s", %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
            self.h.write('#define %sPEEK_%s(object) (g_dbus_object_peek_with_typecheck (G_DBUS_OBJECT (object), "%s", %sTYPE_%s))\n'%(i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
            self.h.write('\n')

            # Then the stub
            self.h.write('\n')
            self.h.write('/* ---- */\n')
            self.h.write('\n')
            self.h.write('#define %sTYPE_%s_STUB (%s_stub_get_gtype ())\n'%(i.ns_upper, i.name_upper, i.name_lower))
            self.h.write('#define %s%s_STUB(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_STUB, %sStub))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_STUB_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_STUB, %sStubClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %s%s_STUB_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_STUB, %sStubClass))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name))
            self.h.write('#define %sIS_%s_STUB(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_STUB))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('#define %sIS_%s_STUB_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_STUB))\n'%(i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))
            self.h.write('\n')
            self.h.write('typedef struct _%sStub %sStub;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sStubClass %sStubClass;\n'%(i.camel_name, i.camel_name))
            self.h.write('typedef struct _%sStubPrivate %sStubPrivate;\n'%(i.camel_name, i.camel_name))
            self.h.write('\n')
            self.h.write('struct _%sStub\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusInterfaceStub parent_instance;\n')
            self.h.write('  %sStubPrivate *priv;\n'%(i.camel_name))
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('struct _%sStubClass\n'%(i.camel_name))
            self.h.write('{\n')
            self.h.write('  GDBusInterfaceStubClass parent_class;\n')
            self.h.write('};\n')
            self.h.write('\n')
            self.h.write('GType %s_stub_get_gtype (void) G_GNUC_CONST;\n'%(i.name_lower))
            self.h.write('\n')
            self.h.write('%s *%s_stub_new (void);\n'%(i.camel_name, i.name_lower))

            self.h.write('\n')

        # Finally, the proxy manager
        self.h.write('\n')
        self.h.write('/* ---- */\n')
        self.h.write('\n')
        self.h.write('#define %sTYPE_OBJECT_MANAGER_CLIENT (%sobject_manager_client_get_gtype ())\n'%(self.ns_upper, self.ns_lower))
        self.h.write('#define %sOBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClient))\n'%(self.ns_upper, self.ns_upper, self.namespace))
        self.h.write('#define %sOBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n'%(self.ns_upper, self.ns_upper, self.namespace))
        self.h.write('#define %sOBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n'%(self.ns_upper, self.ns_upper, self.namespace))
        self.h.write('#define %sIS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_MANAGER_CLIENT))\n'%(self.ns_upper, self.ns_upper))
        self.h.write('#define %sIS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_MANAGER_CLIENT))\n'%(self.ns_upper, self.ns_upper))
        self.h.write('\n')
        self.h.write('typedef struct _%sObjectManagerClient %sObjectManagerClient;\n'%(self.namespace, self.namespace))
        self.h.write('typedef struct _%sObjectManagerClientClass %sObjectManagerClientClass;\n'%(self.namespace, self.namespace))
        self.h.write('typedef struct _%sObjectManagerClientPrivate %sObjectManagerClientPrivate;\n'%(self.namespace, self.namespace))
        self.h.write('\n')
        self.h.write('struct _%sObjectManagerClient\n'%(self.namespace))
        self.h.write('{\n')
        self.h.write('  GDBusObjectManagerClient parent_instance;\n')
        self.h.write('  %sObjectManagerClientPrivate *priv;\n'%(self.namespace))
        self.h.write('};\n')
        self.h.write('\n')
        self.h.write('struct _%sObjectManagerClientClass\n'%(self.namespace))
        self.h.write('{\n')
        self.h.write('  GDBusObjectManagerClientClass parent_class;\n')
        self.h.write('};\n')
        self.h.write('\n')
        self.h.write('GType %sobject_manager_client_get_gtype (void) G_GNUC_CONST;\n'%(self.ns_lower))
        self.h.write('\n')
        self.h.write('GDBusProxyTypeFunc %sobject_manager_client_get_proxy_type_func (void);\n'%(self.ns_lower))
        self.h.write('\n')
        self.h.write('void %sobject_manager_client_new (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data);\n'
                     %(self.ns_lower))
        self.h.write('GDBusObjectManager *%sobject_manager_client_new_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error);\n'
                     %(self.ns_lower))
        self.h.write('GDBusObjectManager *%sobject_manager_client_new_sync (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error);\n'
                     %(self.ns_lower))
        self.h.write('\n')
        self.h.write('void %sobject_manager_client_new_for_bus (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data);\n'
                     %(self.ns_lower))
        self.h.write('GDBusObjectManager *%sobject_manager_client_new_for_bus_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error);\n'
                     %(self.ns_lower))
        self.h.write('GDBusObjectManager *%sobject_manager_client_new_for_bus_sync (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error);\n'
                     %(self.ns_lower))
        self.h.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_outro(self):
        self.h.write('\n'
                     'G_END_DECLS\n'
                     '\n'
                     '#endif /* __%s__ */\n'%(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate_annotations(self, prefix, annotations):
        if annotations == None:
            return

        n = 0
        for a in annotations:
            #self.generate_annotations('%s_%d'%(prefix, n), a.get_annotations())

            # skip internal annotations
            if a.key.startswith('org.gtk.GDBus'):
                continue

            self.c.write('static const GDBusAnnotationInfo %s_%d =\n'
                         '{\n'
                         '  -1,\n'
                         '  "%s",\n'
                         '  "%s",\n'%(prefix, n, a.key, a.value))
            if len(a.annotations) == 0:
                self.c.write('  NULL\n')
            else:
                self.c.write('  (GDBusAnnotationInfo **) &%s_%d_pointers\n'%(prefix, n))
            self.c.write('};\n'
                         '\n')
            n += 1

        if n > 0:
            self.c.write('static const GDBusAnnotationInfo * const %s_pointers[] =\n'
                             '{\n'%(prefix))
            m = 0;
            for a in annotations:
                if a.key.startswith('org.gtk.GDBus'):
                    continue
                self.c.write('  &%s_%d,\n'%(prefix, m))
                m += 1
            self.c.write('  NULL\n'
                         '};\n'
                         '\n')
        return n

    def generate_args(self, prefix, args):
        for a in args:
            num_anno = self.generate_annotations('%s_arg_%s_annotation_info'%(prefix, a.name), a.annotations)

            self.c.write('static const _ExtendedGDBusArgInfo %s_%s =\n'
                         '{\n'
                         '  {\n'
                         '    -1,\n'
                         '    "%s",\n'
                         '    "%s",\n'%(prefix, a.name, a.name, a.signature))
            if num_anno == 0:
                self.c.write('    NULL\n')
            else:
                self.c.write('    (GDBusAnnotationInfo **) &%s_arg_%s_annotation_info_pointers\n'%(prefix, a.name))
            self.c.write('  },\n')
            if not utils.lookup_annotation(a.annotations, 'org.gtk.GDBus.C.ForceGVariant'):
                self.c.write('  FALSE\n')
            else:
                self.c.write('  TRUE\n')
            self.c.write('};\n'
                         '\n')

        if len(args) > 0:
            self.c.write('static const _ExtendedGDBusArgInfo * const %s_pointers[] =\n'
                             '{\n'%(prefix))
            for a in args:
                self.c.write('  &%s_%s,\n'%(prefix, a.name))
            self.c.write('  NULL\n'
                         '};\n'
                         '\n')

    def generate_introspection_for_interface(self, i):
            self.c.write('/* ---- Introspection data for %s ---- */\n'
                         '\n'%(i.name))

            if len(i.methods) > 0:
                for m in i.methods:
                    self.generate_args('_%s_method_info_%s_IN_ARG'%(i.name_lower, m.name_lower), m.in_args)
                    self.generate_args('_%s_method_info_%s_OUT_ARG'%(i.name_lower, m.name_lower), m.out_args)

                    num_anno = self.generate_annotations('_%s_method_%s_annotation_info'%(i.name_lower, m.name_lower), m.annotations)

                    self.c.write('static const _ExtendedGDBusMethodInfo _%s_method_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'%(i.name_lower, m.name_lower, m.name))
                    if len(m.in_args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_method_info_%s_IN_ARG_pointers,\n'%(i.name_lower, m.name_lower))
                    if len(m.out_args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_method_info_%s_OUT_ARG_pointers,\n'%(i.name_lower, m.name_lower))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_method_%s_annotation_info_pointers\n'%(i.name_lower, m.name_lower))
                    self.c.write('  },\n'
                                 '  "handle-%s"\n'
                                 %(m.name_hyphen))
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusMethodInfo * const _%s_method_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for m in i.methods:
                    self.c.write('  &_%s_method_info_%s,\n'%(i.name_lower, m.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            # ---

            if len(i.signals) > 0:
                for s in i.signals:
                    self.generate_args('_%s_signal_info_%s_ARG'%(i.name_lower, s.name_lower), s.args)

                    num_anno = self.generate_annotations('_%s_signal_%s_annotation_info'%(i.name_lower, s.name_lower), s.annotations)
                    self.c.write('static const _ExtendedGDBusSignalInfo _%s_signal_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'%(i.name_lower, s.name_lower, s.name))
                    if len(s.args) == 0:
                        self.c.write('    NULL,\n')
                    else:
                        self.c.write('    (GDBusArgInfo **) &_%s_signal_info_%s_ARG_pointers,\n'%(i.name_lower, s.name_lower))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_signal_%s_annotation_info_pointers\n'%(i.name_lower, s.name_lower))
                    self.c.write('  },\n'
                                 '  "%s"\n'
                                 %(s.name_hyphen))
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusSignalInfo * const _%s_signal_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for s in i.signals:
                    self.c.write('  &_%s_signal_info_%s,\n'%(i.name_lower, s.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            # ---

            if len(i.properties) > 0:
                for p in i.properties:
                    if p.readable and p.writable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE'
                    elif p.readable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_READABLE'
                    elif p.writable:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE'
                    else:
                        access = 'G_DBUS_PROPERTY_INFO_FLAGS_NONE'
                    num_anno = self.generate_annotations('_%s_property_%s_annotation_info'%(i.name_lower, p.name_lower), p.annotations)
                    self.c.write('static const _ExtendedGDBusPropertyInfo _%s_property_info_%s =\n'
                                 '{\n'
                                 '  {\n'
                                 '    -1,\n'
                                 '    "%s",\n'
                                 '    "%s",\n'
                                 '    %s,\n'%(i.name_lower, p.name_lower, p.name, p.arg.signature, access))
                    if num_anno == 0:
                        self.c.write('    NULL\n')
                    else:
                        self.c.write('    (GDBusAnnotationInfo **) &_%s_property_%s_annotation_info_pointers\n'%(i.name_lower, p.name_lower))
                    self.c.write('  },\n'
                                 '  "%s",\n'
                                 %(p.name_hyphen))
                    if not utils.lookup_annotation(p.annotations, 'org.gtk.GDBus.C.ForceGVariant'):
                        self.c.write('  FALSE\n')
                    else:
                        self.c.write('  TRUE\n')
                    self.c.write('};\n'
                                 '\n')

                self.c.write('static const _ExtendedGDBusPropertyInfo * const _%s_property_info_pointers[] =\n'
                             '{\n'%(i.name_lower))
                for p in i.properties:
                    self.c.write('  &_%s_property_info_%s,\n'%(i.name_lower, p.name_lower))
                self.c.write('  NULL\n'
                             '};\n'
                             '\n')

            num_anno = self.generate_annotations('_%s_annotation_info'%(i.name_lower), i.annotations)
            self.c.write('static const GDBusInterfaceInfo _%s_interface_info =\n'
                         '{\n'
                         '  -1,\n'
                         '  "%s",\n'%(i.name_lower, i.name))
            if len(i.methods) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusMethodInfo **) &_%s_method_info_pointers,\n'%(i.name_lower))
            if len(i.signals) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusSignalInfo **) &_%s_signal_info_pointers,\n'%(i.name_lower))
            if len(i.properties) == 0:
                self.c.write('  NULL,\n')
            else:
                self.c.write('  (GDBusPropertyInfo **) &_%s_property_info_pointers,\n'%(i.name_lower))
            if num_anno == 0:
                self.c.write('  NULL\n')
            else:
                self.c.write('  (GDBusAnnotationInfo **) &_%s_annotation_info_pointers\n'%(i.name_lower))
            self.c.write('};\n'
                         '\n')
            self.c.write('\n')
            self.c.write('GDBusInterfaceInfo *\n'
                         '%s_interface_info (void)\n'
                         '{\n'
                         '  return (GDBusInterfaceInfo *) &_%s_interface_info;\n'
                         '}\n'
                         '\n'%(i.name_lower, i.name_lower))

            if len(i.properties) > 0:
                self.c.write('guint\n'
                             '%s_override_properties (GObjectClass *klass, guint property_id_begin)\n'
                             '{\n'%(i.name_lower))
                for p in i.properties:
                    self.c.write ('  g_object_class_override_property (klass, property_id_begin++, "%s");\n'%(p.name_hyphen))
                self.c.write('  return property_id_begin - 1;\n'
                             '}\n'
                             '\n')
            self.c.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_interface(self, i):
        self.c.write('\n')

        self.c.write('static void\n'
                     '%s_default_init (%sIface *iface)\n'
                     '{\n'%(i.name_lower, i.camel_name));

        if len(i.methods) > 0:
            self.c.write('  /* GObject signals for incoming D-Bus method calls: */\n')
            for m in i.methods:
                self.c.write('  g_signal_new ("handle-%s",\n'
                             '    G_TYPE_FROM_INTERFACE (iface),\n'
                             '    G_SIGNAL_RUN_LAST,\n'
                             '    G_STRUCT_OFFSET (%sIface, handle_%s),\n'
                             '    g_signal_accumulator_true_handled,\n'
                             '    NULL,\n' # accu_data
                             '    _cclosure_marshal_generic,\n'
                             '    G_TYPE_BOOLEAN,\n'
                             '    %d,\n'
                             '    G_TYPE_DBUS_METHOD_INVOCATION'
                             %(m.name_hyphen, i.camel_name, m.name_lower, len(m.in_args) + 1))
                for a in m.in_args:
                    self.c.write (', %s'%(a.gtype))
                self.c.write(');\n')
                self.c.write('\n')

        if len(i.signals) > 0:
            self.c.write('  /* GObject signals for received D-Bus signals: */\n')
            for s in i.signals:
                self.c.write('  g_signal_new ("%s",\n'
                             '    G_TYPE_FROM_INTERFACE (iface),\n'
                             '    G_SIGNAL_RUN_LAST,\n'
                             '    G_STRUCT_OFFSET (%sIface, %s),\n'
                             '    NULL,\n' # accumulator
                             '    NULL,\n' # accu_data
                             '    _cclosure_marshal_generic,\n'
                             '    G_TYPE_NONE,\n'
                             '    %d'
                             %(s.name_hyphen, i.camel_name, s.name_lower, len(s.args)))
                for a in s.args:
                    self.c.write (', %s'%(a.gtype))
                self.c.write(');\n')
                self.c.write('\n')

        if len(i.properties) > 0:
            self.c.write('  /* GObject properties for D-Bus properties: */\n')
            for p in i.properties:
                self.c.write('  g_object_interface_install_property (iface,\n')
                if p.arg.gtype == 'G_TYPE_VARIANT':
                    s = 'g_param_spec_variant ("%s", NULL, NULL, G_VARIANT_TYPE ("%s"), NULL'%(p.name_hyphen, p.arg.signature)
                elif p.arg.signature == 'b':
                    s = 'g_param_spec_boolean ("%s", NULL, NULL, FALSE'%(p.name_hyphen)
                elif p.arg.signature == 'y':
                    s = 'g_param_spec_uchar ("%s", NULL, NULL, 0, 255, 0'%(p.name_hyphen)
                elif p.arg.signature == 'n':
                    s = 'g_param_spec_int ("%s", NULL, NULL, G_MININT16, G_MAXINT16, 0'%(p.name_hyphen)
                elif p.arg.signature == 'q':
                    s = 'g_param_spec_uint ("%s", NULL, NULL, 0, G_MAXUINT16, 0'%(p.name_hyphen)
                elif p.arg.signature == 'i':
                    s = 'g_param_spec_int ("%s", NULL, NULL, G_MININT32, G_MAXINT32, 0'%(p.name_hyphen)
                elif p.arg.signature == 'u':
                    s = 'g_param_spec_uint ("%s", NULL, NULL, 0, G_MAXUINT32, 0'%(p.name_hyphen)
                elif p.arg.signature == 'x':
                    s = 'g_param_spec_int64 ("%s", NULL, NULL, G_MININT64, G_MAXINT64, 0'%(p.name_hyphen)
                elif p.arg.signature == 't':
                    s = 'g_param_spec_uint64 ("%s", NULL, NULL, 0, G_MAXUINT64, 0'%(p.name_hyphen)
                elif p.arg.signature == 'd':
                    s = 'g_param_spec_double ("%s", NULL, NULL, -G_MAXDOUBLE, G_MAXDOUBLE, 0.0'%(p.name_hyphen)
                elif p.arg.signature == 's':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'o':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'g':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'ay':
                    s = 'g_param_spec_string ("%s", NULL, NULL, NULL'%(p.name_hyphen)
                elif p.arg.signature == 'as':
                    s = 'g_param_spec_boxed ("%s", NULL, NULL, G_TYPE_STRV'%(p.name_hyphen)
                elif p.arg.signature == 'aay':
                    s = 'g_param_spec_boxed ("%s", NULL, NULL, G_TYPE_STRV'%(p.name_hyphen)
                else:
                    raise RuntimeError('Unsupported gtype %s for GParamSpec'%(p.arg.gtype))
                self.c.write('    %s, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));'%s);
                self.c.write('\n')

        self.c.write('}\n'
                     '\n')

        self.c.write('typedef %sIface %sInterface;\n'%(i.camel_name, i.camel_name))
        self.c.write('#define %s_get_type %s_get_gtype\n'%(i.name_lower, i.name_lower))
        self.c.write('G_DEFINE_INTERFACE (%s, %s, G_TYPE_OBJECT);\n'%(i.camel_name, i.name_lower))
        self.c.write('#undef %s_get_type\n'%(i.name_lower))
        self.c.write('\n')

    # ----------------------------------------------------------------------------------------------------

    def generate_property_accessors(self, i):
        for p in i.properties:
            # getter
            self.c.write('%s\n'
                         '%s_get_%s (%s *object)\n'
                         '{\n'
                         '  %svalue;\n'%(p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in_g))
            self.c.write('  g_object_get (G_OBJECT (object), "%s", &value, NULL);\n'%(p.name_hyphen))
            if p.arg.free_func:
                self.c.write('  if (value != NULL)\n'
                             '    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-%s", (gpointer) value, (GDestroyNotify) %s);\n'
                             '  else\n'
                             '    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-%s", (gpointer) value, NULL);\n'
                             %(p.name_hyphen, p.arg.free_func, p.name_hyphen))
            self.c.write('  return value;\n')
            self.c.write('}\n')
            self.c.write('\n')
            # setter
            self.c.write('void\n'
                         '%s_set_%s (%s *object, %svalue)\n'
                         '{\n'%(i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in, ))
            self.c.write('  g_object_set (G_OBJECT (object), "%s", value, NULL);\n'%(p.name_hyphen))
            self.c.write('}\n')
            self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_signal_emitters(self, i):
        for s in i.signals:
            self.c.write('void\n'
                         '%s_emit_%s (\n'
                         '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
            for a in s.args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n'
                         '  g_signal_emit_by_name (object, "%s"'%(s.name_hyphen))
            for a in s.args:
                self.c.write(', %s'%a.name)
            self.c.write(');\n')
            self.c.write('}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_method_calls(self, i):
        for m in i.methods:
            # async begin
            self.c.write('void\n'
                         '%s_call_%s (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.in_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(',\n'
                         '    GCancellable *cancellable,\n'
                         '    GAsyncReadyCallback callback,\n'
                         '    gpointer user_data)\n'
                         '{\n')
            self.c.write('  g_dbus_proxy_call (G_DBUS_PROXY (proxy),\n'
                         '    "%s",\n'
                         '    g_variant_new ("('%(m.name))
            for a in m.in_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.in_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    cancellable,\n'
                         '    callback,\n'
                         '    user_data);\n')
            self.c.write('}\n'
                         '\n')
            # async finish
            self.c.write('gboolean\n'
                         '%s_call_%s_finish (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.out_args:
                self.c.write(',\n    %sout_%s'%(a.ctype_out, a.name))
            self.c.write(',\n'
                         '    GAsyncResult *res,\n'
                         '    GError **error)\n'
                         '{\n'
                         '  GVariant *_ret;\n'
                         '  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);\n'
                         '  if (_ret == NULL)\n'
                         '    goto _out;\n')
            self.c.write('  g_variant_get (_ret,\n'
                         '                 \"(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_out))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                 out_%s'%(a.name))
            self.c.write(');\n'
                         '  g_variant_unref (_ret);\n')
            self.c.write('_out:\n'
                         '  return _ret != NULL;\n'
                         '}\n'
                         '\n')


            # sync
            self.c.write('gboolean\n'
                         '%s_call_%s_sync (\n'
                         '    %s *proxy'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.in_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            for a in m.out_args:
                self.c.write(',\n    %sout_%s'%(a.ctype_out, a.name))
            self.c.write(',\n'
                         '    GCancellable *cancellable,\n'
                         '    GError **error)\n'
                         '{\n'
                         '  GVariant *_ret;\n')
            self.c.write('  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n'
                         '    "%s",\n'
                         '    g_variant_new ("('%(m.name))
            for a in m.in_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.in_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    cancellable,\n'
                         '    error);\n'
                         '  if (_ret == NULL)\n'
                         '    goto _out;\n')
            self.c.write('  g_variant_get (_ret,\n'
                         '                 \"(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_out))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                 out_%s'%(a.name))
            self.c.write(');\n'
                         '  g_variant_unref (_ret);\n')
            self.c.write('_out:\n'
                         '  return _ret != NULL;\n'
                         '}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_method_completers(self, i):
        for m in i.methods:
            self.c.write('void\n'
                         '%s_complete_%s (\n'
                         '    %s *object,\n'
                         '    GDBusMethodInvocation *invocation'%(i.name_lower, m.name_lower, i.camel_name))
            for a in m.out_args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n')

            self.c.write('  g_dbus_method_invocation_return_value (invocation,\n'
                         '    g_variant_new ("(')
            for a in m.out_args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in m.out_args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('));\n'
                         '}\n'
                         '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_proxy(self, i):
        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')
        self.c.write('static void\n'
                     '%s_proxy_iface_init (%sIface *iface)\n'
                     '{\n'
                     '}\n'
                     '\n'%(i.name_lower, i.camel_name))
        self.c.write('#define %s_proxy_get_type %s_proxy_get_gtype\n'%(i.name_lower, i.name_lower))
        self.c.write('G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n'%(i.camel_name, i.name_lower))
        self.c.write('                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init));\n'%(i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('#undef %s_proxy_get_type\n'
                     '\n'%(i.name_lower))

        # property accessors
        #
        # Note that we are guaranteed that prop_id starts at 1 and is
        # laid out in the same order as introspection data pointers
        #
        self.c.write('static void\n'
                     '%s_proxy_get_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  GValue       *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  const _ExtendedGDBusPropertyInfo *info;\n'
                         '  GVariant *variant;\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  info = _%s_property_info_pointers[prop_id - 1];\n'
                         '  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);\n'
                         '  if (info->use_gvariant)\n'
                         '    g_value_set_variant (value, variant);\n'
                         '  else\n'
                         '    g_dbus_gvariant_to_gvalue (variant, value);\n'
                         '  if (variant != NULL)\n'
                         '    g_variant_unref (variant);\n'
                         %(len(i.properties), i.name_lower))
        self.c.write('}\n'
                     '\n')
        if len(i.properties) > 0:
            self.c.write('static void\n'
                         '%s_proxy_set_property_cb (GDBusProxy *proxy,\n'
                         '  GAsyncResult *res,\n'
                         '  gpointer      user_data)\n'
                         '{\n'%(i.name_lower))
            self.c.write('  const _ExtendedGDBusPropertyInfo *info = user_data;\n'
                         '  GError *error;\n'
                         '  error = NULL;\n'
                         '  if (!g_dbus_proxy_call_finish (proxy, res, &error))\n'
                         '    {\n'
                         '      g_warning ("Error setting property `%%s\' on interface %s: %%s (%%s, %%d)",\n'
                         '                 info->parent_struct.name, \n'
                         '                 error->message, g_quark_to_string (error->domain), error->code);\n'
                         '      g_error_free (error);\n'
                         '    }\n'
                         %(i.name))
            self.c.write('}\n'
                         '\n')
        self.c.write('static void\n'
                     '%s_proxy_set_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  const GValue *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  const _ExtendedGDBusPropertyInfo *info;\n'
                         '  GVariant *variant;\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  info = _%s_property_info_pointers[prop_id - 1];\n'
                         '  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));\n'
                         '  g_dbus_proxy_call (G_DBUS_PROXY (object),\n'
                         '    "org.freedesktop.DBus.Properties.Set",\n'
                         '    g_variant_new ("(ssv)", "%s", info->parent_struct.name, variant),\n'
                         '    G_DBUS_CALL_FLAGS_NONE,\n'
                         '    -1,\n'
                         '    NULL, (GAsyncReadyCallback) %s_proxy_set_property_cb, (gpointer) info);\n'
                         '  g_variant_unref (variant);\n'
                         %(len(i.properties), i.name_lower, i.name, i.name_lower))
        self.c.write('}\n'
                     '\n')

        # signal received
        self.c.write('static void\n'
                     '%s_proxy_g_signal (GDBusProxy *proxy,\n'
                     '  const gchar *sender_name,\n'
                     '  const gchar *signal_name,\n'
                     '  GVariant *parameters)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  _ExtendedGDBusSignalInfo *info;\n'
                     '  GVariantIter iter;\n'
                     '  GVariant *child;\n'
                     '  GValue *paramv;\n'
                     '  guint num_params;\n'
                     '  guint n;\n'
                     '  guint signal_id;\n');
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.c.write('  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_%s_interface_info, signal_name);\n'
                     '  if (info == NULL)\n'
                     '    return;\n'
                     %(i.name_lower))
        self.c.write ('  num_params = g_variant_n_children (parameters);\n'
                      '  paramv = g_new0 (GValue, num_params + 1);\n'
                      '  g_value_init (&paramv[0], %sTYPE_%s);\n'
                      '  g_value_set_object (&paramv[0], proxy);\n'
                      %(i.ns_upper, i.name_upper))
        self.c.write('  g_variant_iter_init (&iter, parameters);\n'
                     '  n = 1;\n'
                     '  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n'
                     '    {\n'
                     '      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];\n'
                     '      if (arg_info->use_gvariant)\n'
                     '        {\n'
                     '          g_value_init (&paramv[n], G_TYPE_VARIANT);\n'
                     '          g_value_set_variant (&paramv[n], child);\n'
                     '          n++;\n'
                     '        }\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n'
                     '      g_variant_unref (child);\n'
                     '    }\n'
                     )
        self.c.write('  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n'
                     %(i.ns_upper, i.name_upper))
        self.c.write('  g_signal_emitv (paramv, signal_id, 0, NULL);\n')
        self.c.write('  for (n = 0; n < num_params + 1; n++)\n'
                     '    g_value_unset (&paramv[n]);\n'
                     '  g_free (paramv);\n')
        self.c.write('}\n'
                     '\n')

        # property changed
        self.c.write('static void\n'
                     '%s_proxy_g_properties_changed (GDBusProxy *proxy,\n'
                     '  GVariant *changed_properties,\n'
                     '  const gchar *const *invalidated_properties)\n'
                     '{\n'%(i.name_lower))
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.c.write('  guint n;\n'
                     '  const gchar *key;\n'
                     '  GVariantIter *iter;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  g_variant_get (changed_properties, "a{sv}", &iter);\n'
                     '  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))\n'
                     '    {\n'
                     '      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, key);\n'
                     '      if (info != NULL)\n'
                     '        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n'
                     '    }\n'
                     '  g_variant_iter_free (iter);\n'
                     '  for (n = 0; invalidated_properties[n] != NULL; n++)\n'
                     '    {\n'
                     '      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, invalidated_properties[n]);\n'
                     '      if (info != NULL)\n'
                     '        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n'
                     '    }\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.name_lower))

        # class boilerplate
        self.c.write('static void\n'
                     '%s_proxy_init (%sProxy *proxy)\n'
                     '{\n'
                     '  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), %s_interface_info ());\n'
                     '}\n'
                     '\n'%(i.name_lower, i.camel_name, i.name_lower))
        self.c.write('static void\n'
                     '%s_proxy_class_init (%sProxyClass *klass)\n'
                     '{\n'
                     '  GObjectClass *gobject_class;\n'
                     '  GDBusProxyClass *proxy_class;\n'
                     '\n'
                     '  gobject_class = G_OBJECT_CLASS (klass);\n'
                     '  gobject_class->get_property = %s_proxy_get_property;\n'
                     '  gobject_class->set_property = %s_proxy_set_property;\n'
                     '\n'
                     '  proxy_class = G_DBUS_PROXY_CLASS (klass);\n'
                     '  proxy_class->g_signal = %s_proxy_g_signal;\n'
                     '  proxy_class->g_properties_changed = %s_proxy_g_properties_changed;\n'
                     '\n'%(i.name_lower, i.camel_name, i.name_lower, i.name_lower, i.name_lower, i.name_lower))
        if len(i.properties) > 0:
            self.c.write('\n'
                         '  %s_override_properties (gobject_class, 1);\n'%(i.name_lower))
        self.c.write('}\n')

        # constructors
        self.c.write('void\n'
                     '%s_proxy_new (\n'
                     '    GDBusConnection     *connection,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GAsyncReadyCallback  callback,\n'
                     '    gpointer             user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.ns_upper, i.name_upper, i.name))
        self.c.write('%s *\n'
                     '%s_proxy_new_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper))
        self.c.write('%s *\n'
                     '%s_proxy_new_sync (\n'
                     '    GDBusConnection     *connection,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
        self.c.write('\n')
        self.c.write('void\n'
                     '%s_proxy_new_for_bus (\n'
                     '    GBusType             bus_type,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GAsyncReadyCallback  callback,\n'
                     '    gpointer             user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.ns_upper, i.name_upper, i.name))
        self.c.write('%s *\n'
                     '%s_proxy_new_for_bus_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper))
        self.c.write('%s *\n'
                     '%s_proxy_new_for_bus_sync (\n'
                     '    GBusType             bus_type,\n'
                     '    GDBusProxyFlags      flags,\n'
                     '    const gchar         *name,\n'
                     '    const gchar         *object_path,\n'
                     '    GCancellable        *cancellable,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return %s%s (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.name, i.ns_upper, i.name_upper))
        self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_stub(self, i):
        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')

        self.c.write('struct _%sStubPrivate\n'
                     '{\n'
                     '  GValueArray *properties;\n'
                     '  GList *changed_properties;\n'
                     '  GSource *changed_properties_idle_source;\n'
                     '  GMainContext *context;\n'
                     '};\n'
                     '\n'%i.camel_name)

        self.c.write('static void\n'
                     '_%s_stub_handle_method_call (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *method_name,\n'
                     '  GVariant *parameters,\n'
                     '  GDBusMethodInvocation *invocation,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sStub *stub = %s%s_STUB (user_data);\n'
                     '  _ExtendedGDBusMethodInfo *info;\n'
                     '  GVariantIter iter;\n'
                     '  GVariant *child;\n'
                     '  GValue *paramv;\n'
                     '  guint num_params;\n'
                     '  guint n;\n'
                     '  guint signal_id;\n'
                     '  GValue return_value = {0};\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);\n'
                     '  g_assert (info != NULL);\n'
                     %())
        self.c.write ('  num_params = g_variant_n_children (parameters);\n'
                      '  paramv = g_new0 (GValue, num_params + 2);\n'
                      '  g_value_init (&paramv[0], %sTYPE_%s);\n'
                      '  g_value_set_object (&paramv[0], stub);\n'
                      '  g_value_init (&paramv[1], G_TYPE_DBUS_METHOD_INVOCATION);\n'
                      '  g_value_set_object (&paramv[1], invocation);\n'
                      %(i.ns_upper, i.name_upper))
        self.c.write('  g_variant_iter_init (&iter, parameters);\n'
                     '  n = 2;\n'
                     '  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n'
                     '    {\n'
                     '      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - 2];\n'
                     '      if (arg_info->use_gvariant)\n'
                     '        {\n'
                     '          g_value_init (&paramv[n], G_TYPE_VARIANT);\n'
                     '          g_value_set_variant (&paramv[n], child);\n'
                     '          n++;\n'
                     '        }\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n'
                     '      g_variant_unref (child);\n'
                     '    }\n'
                     )
        self.c.write('  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n'
                     %(i.ns_upper, i.name_upper))
        self.c.write('  g_value_init (&return_value, G_TYPE_BOOLEAN);\n'
                     '  g_signal_emitv (paramv, signal_id, 0, &return_value);\n'
                     '  if (!g_value_get_boolean (&return_value))\n'
                     '    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);\n'
                     '  g_value_unset (&return_value);\n'
                     )
        self.c.write('  for (n = 0; n < num_params + 2; n++)\n'
                     '    g_value_unset (&paramv[n]);\n'
                     '  g_free (paramv);\n')
        self.c.write('}\n'
                     '\n')

        self.c.write('static GVariant *\n'
                     '_%s_stub_handle_get_property (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *property_name,\n'
                     '  GError **error,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sStub *stub = %s%s_STUB (user_data);\n'
                     '  GValue value = {0};\n'
                     '  GParamSpec *pspec;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  GVariant *ret;\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  ret = NULL;\n'
                     '  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, property_name);\n'
                     '  g_assert (info != NULL);\n'
                     '  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (stub), info->hyphen_name);\n'
                     '  if (pspec == NULL)\n'
                     '    {\n'
                     '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
                     '    }\n'
                     '  else\n'
                     '    {\n'
                     '      g_value_init (&value, pspec->value_type);\n'
                     '      g_object_get_property (G_OBJECT (stub), info->hyphen_name, &value);\n'
                     '      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));\n'
                     '      g_value_unset (&value);\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n'
                     %(i.name_lower))

        self.c.write('static gboolean\n'
                     '_%s_stub_handle_set_property (\n'
                     '  GDBusConnection *connection,\n'
                     '  const gchar *sender,\n'
                     '  const gchar *object_path,\n'
                     '  const gchar *interface_name,\n'
                     '  const gchar *property_name,\n'
                     '  GVariant *variant,\n'
                     '  GError **error,\n'
                     '  gpointer user_data)\n'
                     '{\n'
                     '  %sStub *stub = %s%s_STUB (user_data);\n'
                     '  GValue value = {0};\n'
                     '  GParamSpec *pspec;\n'
                     '  _ExtendedGDBusPropertyInfo *info;\n'
                     '  gboolean ret;\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('  ret = FALSE;\n'
                     '  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info, property_name);\n'
                     '  g_assert (info != NULL);\n'
                     '  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (stub), info->hyphen_name);\n'
                     '  if (pspec == NULL)\n'
                     '    {\n'
                     '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
                     '    }\n'
                     '  else\n'
                     '    {\n'
                     '      if (info->use_gvariant)\n'
                     '        g_value_set_variant (&value, variant);\n'
                     '      else\n'
                     '        g_dbus_gvariant_to_gvalue (variant, &value);\n'
                     '      g_object_set_property (G_OBJECT (stub), info->hyphen_name, &value);\n'
                     '      g_value_unset (&value);\n'
                     '      ret = TRUE;\n'
                     '    }\n'
                     '  return ret;\n'
                     '}\n'
                     '\n'
                     %(i.name_lower))


        self.c.write('static const GDBusInterfaceVTable _%s_stub_vtable =\n'
                     '{\n'
                     '  _%s_stub_handle_method_call,\n'
                     '  _%s_stub_handle_get_property,\n'
                     '  _%s_stub_handle_set_property\n'
                     '};\n'
                     '\n'%(i.name_lower, i.name_lower, i.name_lower, i.name_lower))

        self.c.write('static GDBusInterfaceInfo *\n'
                     '%s_stub_dbus_interface_get_info (GDBusInterfaceStub *stub)\n'
                     '{\n'
                     '  return %s_interface_info ();\n'
                     %(i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static GDBusInterfaceVTable *\n'
                     '%s_stub_dbus_interface_get_vtable (GDBusInterfaceStub *stub)\n'
                     '{\n'
                     '  return (GDBusInterfaceVTable *) &_%s_stub_vtable;\n'
                     %(i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static GVariant *\n'
                     '%s_stub_dbus_interface_get_properties (GDBusInterfaceStub *_stub)\n'
                     '{\n'
                     '  %sStub *stub = %s%s_STUB (_stub);\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
        self.c.write('\n'
                     '  GVariantBuilder builder;\n'
                     '  guint n;\n'
                     '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                     '  if (_%s_interface_info.properties == NULL)\n'
                     '    goto out;\n'
                     '  for (n = 0; _%s_interface_info.properties[n] != NULL; n++)\n'
                     '    {\n'
                     '      GDBusPropertyInfo *info = _%s_interface_info.properties[n];\n'
                     '      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n'
                     '        {\n'
                     '          GVariant *value;\n'
                     '          value = _%s_stub_handle_get_property (g_dbus_interface_stub_get_connection (G_DBUS_INTERFACE_STUB (stub)), NULL, g_dbus_interface_stub_get_object_path (G_DBUS_INTERFACE_STUB (stub)), "%s", info->name, NULL, stub);\n'
                     '          if (value != NULL)\n'
                     '            {\n'
                     '              if (g_variant_is_floating (value))\n'
                     '                g_variant_ref_sink (value);\n'
                     '              g_variant_builder_add (&builder, "{sv}", info->name, value);\n'
                     '              g_variant_unref (value);\n'
                     '            }\n'
                     '        }\n'
                     '    }\n'
                     'out:\n'
                     '  return g_variant_builder_end (&builder);\n'
                     '}\n'
                     '\n'
                     %(i.name_lower, i.name_lower, i.name_lower, i.name_lower, i.name))

        if len(i.properties) > 0:
            self.c.write('static gboolean _%s_emit_changed (gpointer user_data);\n'
                         '\n'
                         %(i.name_lower))

        self.c.write('static void\n'
                     '%s_stub_dbus_interface_flush (GDBusInterfaceStub *_stub)\n'
                     '{\n'
                     %(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  %sStub *stub = %s%s_STUB (_stub);\n'
                         '  if (stub->priv->changed_properties_idle_source != NULL)\n'
                         '    {\n'
                         '      g_source_destroy (stub->priv->changed_properties_idle_source);\n'
                         '      stub->priv->changed_properties_idle_source = NULL;\n'
                         '      _%s_emit_changed (stub);\n'
                         '    }\n'
                         %(i.camel_name, i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('}\n'
                     '\n')

        for s in i.signals:
            self.c.write('static void\n'
                         '_%s_on_signal_%s (\n'
                         '    %s *object'%(i.name_lower, s.name_lower, i.camel_name))
            for a in s.args:
                self.c.write(',\n    %s%s'%(a.ctype_in, a.name))
            self.c.write(')\n'
                         '{\n'
                         '  %sStub *stub = %s%s_STUB (object);\n'
                         '  GDBusConnection *connection = g_dbus_interface_stub_get_connection (G_DBUS_INTERFACE_STUB (stub));\n'
                         %(i.camel_name, i.ns_upper, i.name_upper))
            self.c.write('  if (connection == NULL)\n'
                         '    return;\n'
                         '  g_dbus_connection_emit_signal (connection,\n'
                         '    NULL, g_dbus_interface_stub_get_object_path (G_DBUS_INTERFACE_STUB (stub)), "%s", "%s",\n'
                         '    g_variant_new ("('
                         %(i.name, s.name))
            for a in s.args:
                self.c.write('%s'%(a.format_in))
            self.c.write(')"')
            for a in s.args:
                self.c.write(',\n                   %s'%(a.name))
            self.c.write('), NULL);\n')
            self.c.write('}\n'
                         '\n')

        self.c.write('static void\n'
                     '%s_stub_iface_init (%sIface *iface)\n'
                     '{\n'
                     %(i.name_lower, i.camel_name))
        for s in i.signals:
            self.c.write('  iface->%s = _%s_on_signal_%s;\n'
                         %(s.name_lower, i.name_lower, s.name_lower))
        self.c.write('}\n'
                     '\n')
        self.c.write('#define %s_stub_get_type %s_stub_get_gtype\n'%(i.name_lower, i.name_lower))
        self.c.write('G_DEFINE_TYPE_WITH_CODE (%sStub, %s_stub, G_TYPE_DBUS_INTERFACE_STUB,\n'%(i.camel_name, i.name_lower))
        self.c.write('                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_stub_iface_init));\n'%(i.ns_upper, i.name_upper, i.name_lower))
        self.c.write('#undef %s_stub_get_type\n'
                     '\n'%(i.name_lower))

        # finalize
        self.c.write('static void\n'
                     '%s_stub_finalize (GObject *object)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  %sStub *stub = %s%s_STUB (object);\n'%(i.camel_name, i.ns_upper, i.name_upper))
        if len(i.properties) > 0:
            self.c.write('  g_value_array_free (stub->priv->properties);\n')
        self.c.write('  g_list_foreach (stub->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
        self.c.write('  g_list_free (stub->priv->changed_properties);\n')
        self.c.write('  if (stub->priv->changed_properties_idle_source != NULL)\n')
        self.c.write('    g_source_destroy (stub->priv->changed_properties_idle_source);\n')
        self.c.write('  if (stub->priv->context != NULL)\n')
        self.c.write('    g_main_context_unref (stub->priv->context);\n')
        self.c.write('  G_OBJECT_CLASS (%s_stub_parent_class)->finalize (object);\n'
                     '}\n'
                     '\n'%(i.name_lower))

        # property accessors (TODO: generate PropertiesChanged signals in setter)
        self.c.write('static void\n'
                     '%s_stub_get_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  GValue       *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        self.c.write('  %sStub *stub = %s%s_STUB (object);\n'
                     '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                     '  g_value_copy (&stub->priv->properties->values[prop_id - 1], value);\n'
                     %(i.camel_name, i.ns_upper, i.name_upper, len(i.properties)))
        self.c.write('}\n'
                     '\n')
        if len(i.properties) > 0:
            self.c.write('static gboolean\n'
                         '_%s_emit_changed (gpointer user_data)\n'
                         '{\n'
                         '  %sStub *stub = %s%s_STUB (user_data);\n'
                         %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper))
            self.c.write('  GList *l;\n'
                         '  GVariantBuilder builder;\n'
                         '  GVariantBuilder invalidated_builder;\n'
                         '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                         '  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));\n'
                         '  for (l = stub->priv->changed_properties; l != NULL; l = l->next)\n'
                         '    {\n'
                         '      ChangedProperty *cp = l->data;\n'
                         '      GVariant *variant;\n'
                         '      variant = g_dbus_gvalue_to_gvariant (&cp->value, G_VARIANT_TYPE (cp->info->parent_struct.signature));\n'
                         '      g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);\n'
                         '      g_variant_unref (variant);\n'
                         '    }\n'
                         '  g_dbus_connection_emit_signal (g_dbus_interface_stub_get_connection (G_DBUS_INTERFACE_STUB (stub)),\n'
                         '                                 NULL, g_dbus_interface_stub_get_object_path (G_DBUS_INTERFACE_STUB (stub)),\n'
                         '                                 "org.freedesktop.DBus.Properties",\n'
                         '                                 "PropertiesChanged",\n'
                         '                                 g_variant_new ("(sa{sv}as)",\n'
                         '                                                "%s",\n'
                         '                                                &builder, &invalidated_builder),\n'
                         '                                 NULL);\n'
                         %(i.name))
            self.c.write('  g_list_foreach (stub->priv->changed_properties, (GFunc) _changed_property_free, NULL);\n')
            self.c.write('  g_list_free (stub->priv->changed_properties);\n')
            self.c.write('  stub->priv->changed_properties = NULL;\n')
            self.c.write('  stub->priv->changed_properties_idle_source = NULL;\n')
            self.c.write('  return FALSE;\n'
                         '}\n'
                         '\n')
            # if property is already scheduled then re-use entry
            self.c.write('static void\n'
                         '_%s_schedule_emit_changed (%sStub *stub, const _ExtendedGDBusPropertyInfo *info, GParamSpec *pspec, const GValue *value)\n'
                         '{\n'
                         '  ChangedProperty *cp;\n'
                         '  GList *l;\n'
                         '  cp = NULL;\n'
                         '  for (l = stub->priv->changed_properties; l != NULL; l = l->next)\n'
                         '    {\n'
                         '      ChangedProperty *i_cp = l->data;\n'
                         '      if (i_cp->info == info)\n'
                         '        {\n'
                         '          cp = i_cp;\n'
                         '          g_value_unset (&cp->value);\n'
                         '          break;\n'
                         '        }\n'
                         '    }\n'
                         '  if (cp == NULL)\n'
                         '    {\n'
                         '      cp = g_new0 (ChangedProperty, 1);\n'
                         '      cp->pspec = pspec;\n'
                         '      cp->info = info;\n'
                         '      stub->priv->changed_properties = g_list_prepend (stub->priv->changed_properties, cp);\n'
                         '    }\n'
                         '  g_value_init (&cp->value, G_VALUE_TYPE (value));\n'
                         '  g_value_copy (value, &cp->value);\n'
                         '  if (stub->priv->changed_properties_idle_source == NULL)\n'
                         '    {\n'
                         '      stub->priv->changed_properties_idle_source = g_idle_source_new ();\n'
                         '      g_source_set_priority (stub->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);\n'
                         '      g_source_set_callback (stub->priv->changed_properties_idle_source, _%s_emit_changed, g_object_ref (stub), (GDestroyNotify) g_object_unref);\n'
                         '      g_source_attach (stub->priv->changed_properties_idle_source, stub->priv->context);\n'
                         '      g_source_unref (stub->priv->changed_properties_idle_source);\n'
                         '    }\n'
                         '}\n'
                         '\n'
                         %(i.name_lower, i.camel_name, i.name_lower))
        self.c.write('static void\n'
                     '%s_stub_set_property (GObject      *object,\n'
                     '  guint         prop_id,\n'
                     '  const GValue *value,\n'
                     '  GParamSpec   *pspec)\n'
                     '{\n'%(i.name_lower))
        if len(i.properties) > 0:
            self.c.write('  %sStub *stub = %s%s_STUB (object);\n'
                         '  g_assert (prop_id - 1 >= 0 && prop_id - 1 < %d);\n'
                         '  if (!_g_value_equal (value, &stub->priv->properties->values[prop_id - 1]))\n'
                         '    {\n'
                         '      g_value_copy (value, &stub->priv->properties->values[prop_id - 1]);\n'
                         '      g_object_notify_by_pspec (object, pspec);\n'
                         '      if (g_dbus_interface_stub_get_connection (G_DBUS_INTERFACE_STUB (stub)) != NULL)\n'
                         '        _%s_schedule_emit_changed (stub, _%s_property_info_pointers[prop_id - 1], pspec, value);\n'
                         '    }\n'
                         %(i.camel_name, i.ns_upper, i.name_upper, len(i.properties), i.name_lower, i.name_lower))
        self.c.write('}\n'
                     '\n')

        self.c.write('static void\n'
                     '%s_stub_init (%sStub *stub)\n'
                     '{\n'
                     '  stub->priv = G_TYPE_INSTANCE_GET_PRIVATE (stub, %sTYPE_%s_STUB, %sStubPrivate);\n'
                     %(i.name_lower, i.camel_name, i.ns_upper, i.name_upper, i.camel_name))
        self.c.write('  stub->priv->context = g_main_context_get_thread_default ();\n')
        self.c.write('  if (stub->priv->context != NULL)\n')
        self.c.write('    g_main_context_ref (stub->priv->context);\n')
        if len(i.properties) > 0:
            self.c.write('  stub->priv->properties = g_value_array_new (%d);\n'%(len(i.properties)))
            n = 0
            for p in i.properties:
                self.c.write('  g_value_array_append (stub->priv->properties, NULL);\n')
                self.c.write('  g_value_init (&stub->priv->properties->values[%d], %s);\n'%(n, p.arg.gtype))
                n += 1
        self.c.write('}\n'
                     '\n')
        self.c.write('static void\n'
                     '%s_stub_class_init (%sStubClass *klass)\n'
                     '{\n'
                     '  GObjectClass *gobject_class;\n'
                     '  GDBusInterfaceStubClass *stub_class;\n'
                     '\n'
                     '  g_type_class_add_private (klass, sizeof (%sStubPrivate));\n'
                     '\n'
                     '  gobject_class = G_OBJECT_CLASS (klass);\n'
                     '  gobject_class->finalize = %s_stub_finalize;\n'
                     '  gobject_class->get_property = %s_stub_get_property;\n'
                     '  gobject_class->set_property = %s_stub_set_property;\n'
                     '\n'%(i.name_lower, i.camel_name, i.camel_name, i.name_lower, i.name_lower, i.name_lower))
        if len(i.properties) > 0:
            self.c.write('\n'
                         '  %s_override_properties (gobject_class, 1);\n'%(i.name_lower))
        self.c.write('\n'
                     '  stub_class = G_DBUS_INTERFACE_STUB_CLASS (klass);\n');
        self.c.write('  stub_class->get_info = %s_stub_dbus_interface_get_info;\n'%(i.name_lower))
        self.c.write('  stub_class->get_properties = %s_stub_dbus_interface_get_properties;\n'%(i.name_lower))
        self.c.write('  stub_class->flush = %s_stub_dbus_interface_flush;\n'%(i.name_lower))
        self.c.write('  stub_class->get_vtable = %s_stub_dbus_interface_get_vtable;\n'%(i.name_lower))
        self.c.write('}\n'
                     '\n')

        # constructors
        self.c.write('%s *\n'
                     '%s_stub_new (void)\n'
                     '{\n'
                     '  return %s%s (g_object_new (%sTYPE_%s_STUB, NULL));\n'
                     '}\n'
                     '\n'%(i.camel_name, i.name_lower, i.ns_upper, i.name_upper, i.ns_upper, i.name_upper))

    # ---------------------------------------------------------------------------------------------------

    # From https://bugzilla.gnome.org/show_bug.cgi?id=567087
    #
    # See https://bugzilla.gnome.org/show_bug.cgi?id=401080 for the request
    # to include this in libgobject
    #
    def generate_generic_marshaller(self):
        self.c.write('#include <ffi.h>\n'
                     ''
                     'static ffi_type *\n'
                     'value_to_ffi_type (const GValue *gvalue, gpointer *value)\n'
                     '{\n'
                     '  ffi_type *rettype = NULL;\n'
                     '  GType type = g_type_fundamental (G_VALUE_TYPE (gvalue));\n'
                     '  g_assert (type != G_TYPE_INVALID);\n'
                     '\n'
                     '  switch (type)\n'
                     '    {\n'
                     '    case G_TYPE_BOOLEAN:\n'
                     '    case G_TYPE_CHAR:\n'
                     '    case G_TYPE_INT:\n'
                     '      rettype = &ffi_type_sint;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_int);\n'
                     '      break;\n'
                     '    case G_TYPE_UCHAR:\n'
                     '    case G_TYPE_UINT:\n'
                     '      rettype = &ffi_type_uint;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_uint);\n'
                     '      break;\n'
                     '    case G_TYPE_STRING:\n'
                     '    case G_TYPE_OBJECT:\n'
                     '    case G_TYPE_BOXED:\n'
                     '    case G_TYPE_POINTER:\n'
                     '    case G_TYPE_INTERFACE:\n'
                     '    case G_TYPE_VARIANT:\n'
                     '      rettype = &ffi_type_pointer;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_pointer);\n'
                     '      break;\n'
                     '    case G_TYPE_FLOAT:\n'
                     '      rettype = &ffi_type_float;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_float);\n'
                     '      break;\n'
                     '    case G_TYPE_DOUBLE:\n'
                     '      rettype = &ffi_type_double;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_double);\n'
                     '      break;\n'
                     '    case G_TYPE_LONG:\n'
                     '      rettype = &ffi_type_slong;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_long);\n'
                     '      break;\n'
                     '    case G_TYPE_ULONG:\n'
                     '      rettype = &ffi_type_ulong;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_ulong);\n'
                     '      break;\n'
                     '    case G_TYPE_INT64:\n'
                     '      rettype = &ffi_type_sint64;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_int64);\n'
                     '      break;\n'
                     '    case G_TYPE_UINT64:\n'
                     '      rettype = &ffi_type_uint64;\n'
                     '      *value = (gpointer)&(gvalue->data[0].v_uint64);\n'
                     '      break;\n'
                     '    default:\n'
                     '      rettype = &ffi_type_pointer;\n'
                     '      *value = NULL;\n'
                     '      g_warning ("value_to_ffi_type: Unsupported fundamental type: %s", g_type_name (type));\n'
                     '      break;\n'
                     '    }\n'
                     '  return rettype;\n'
                     '}\n'
                     '\n'
                     'static void\n'
                     'value_from_ffi_type (GValue *gvalue, gpointer *value)\n'
                     '{\n'
                     '  switch (g_type_fundamental (G_VALUE_TYPE (gvalue)))\n'
                     '    {\n'
                     '    case G_TYPE_INT:\n'
                     '      g_value_set_int (gvalue, *(gint*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_FLOAT:\n'
                     '      g_value_set_float (gvalue, *(gfloat*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_DOUBLE:\n'
                     '      g_value_set_double (gvalue, *(gdouble*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_BOOLEAN:\n'
                     '      g_value_set_boolean (gvalue, *(gboolean*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_STRING:\n'
                     '      g_value_set_string (gvalue, *(gchar**)value);\n'
                     '      break;\n'
                     '    case G_TYPE_CHAR:\n'
                     '      g_value_set_char (gvalue, *(gchar*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_UCHAR:\n'
                     '      g_value_set_uchar (gvalue, *(guchar*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_UINT:\n'
                     '      g_value_set_uint (gvalue, *(guint*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_POINTER:\n'
                     '      g_value_set_pointer (gvalue, *(gpointer*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_LONG:\n'
                     '      g_value_set_long (gvalue, *(glong*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_ULONG:\n'
                     '      g_value_set_ulong (gvalue, *(gulong*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_INT64:\n'
                     '      g_value_set_int64 (gvalue, *(gint64*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_UINT64:\n'
                     '      g_value_set_uint64 (gvalue, *(guint64*)value);\n'
                     '      break;\n'
                     '    case G_TYPE_BOXED:\n'
                     '      g_value_set_boxed (gvalue, *(gpointer*)value);\n'
                     '      break;\n'
                     '    default:\n'
                     '      g_warning ("value_from_ffi_type: Unsupported fundamental type: %s",\n'
                     '                g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));\n'
                     '    }\n'
                     '}\n'
                     '\n'
                     'static void\n'
                     '_cclosure_marshal_generic (GClosure *closure,\n'
                     '                             GValue *return_gvalue,\n'
                     '                             guint n_param_values,\n'
                     '                             const GValue *param_values,\n'
                     '                             gpointer invocation_hint,\n'
                     '                             gpointer marshal_data)\n'
                     '{\n'
                     '  ffi_type *rtype;\n'
                     '  void *rvalue;\n'
                     '  int n_args;\n'
                     '  ffi_type **atypes;\n'
                     '  void **args;\n'
                     '  int i;\n'
                     '  ffi_cif cif;\n'
                     '  GCClosure *cc = (GCClosure*) closure;\n'
                     '\n'
                     '  if (return_gvalue && G_VALUE_TYPE (return_gvalue)) \n'
                     '    {\n'
                     '      rtype = value_to_ffi_type (return_gvalue, &rvalue);\n'
                     '    }\n'
                     '  else \n'
                     '    {\n'
                     '      rtype = &ffi_type_void;\n'
                     '    }\n'
                     '\n'
                     '  rvalue = g_alloca (MAX (rtype->size, sizeof (ffi_arg)));\n'
                     '  \n'
                     '  n_args = n_param_values + 1;\n'
                     '  atypes = g_alloca (sizeof (ffi_type *) * n_args);\n'
                     '  args =  g_alloca (sizeof (gpointer) * n_args);\n'
                     '\n'
                     '  if (G_CCLOSURE_SWAP_DATA (closure))\n'
                     '    {\n'
                     '      atypes[n_args-1] = value_to_ffi_type (param_values + 0,  \n'
                     '                                            &args[n_args-1]);\n'
                     '      atypes[0] = &ffi_type_pointer;\n'
                     '      args[0] = &closure->data;\n'
                     '    }\n'
                     '  else\n'
                     '    {\n'
                     '      atypes[0] = value_to_ffi_type (param_values + 0, &args[0]);\n'
                     '      atypes[n_args-1] = &ffi_type_pointer;\n'
                     '      args[n_args-1] = &closure->data;\n'
                     '    }\n'
                     '\n'
                     '  for (i = 1; i < n_args - 1; i++)\n'
                     '    atypes[i] = value_to_ffi_type (param_values + i, &args[i]);\n'
                     '\n'
                     '  if (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)\n'
                     '    return;\n'
                     '\n'
                     '  ffi_call (&cif, marshal_data ? marshal_data : cc->callback, rvalue, args);\n'
                     '\n'
                     '  if (return_gvalue && G_VALUE_TYPE (return_gvalue))\n'
                     '    value_from_ffi_type (return_gvalue, rvalue);\n'
                     '}\n'
                     '\n')

    # ---------------------------------------------------------------------------------------------------

    def generate_object_manager_client(self):
        self.c.write('/* ------------------------------------------------------------------------\n'
                     ' * Code for proxy manager\n'
                     ' * ------------------------------------------------------------------------\n'
                     ' */\n'
                     '\n')

        # class boilerplate
        self.c.write('/* ------------------------------------------------------------------------ */\n'
                     '\n')
        self.c.write('#define %sobject_manager_client_get_type %sobject_manager_client_get_gtype\n'%(self.ns_lower, self.ns_lower))
        self.c.write('G_DEFINE_TYPE (%sObjectManagerClient, %sobject_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);\n'%(self.namespace, self.ns_lower))
        self.c.write('#undef %sobject_manager_client_get_type\n'
                     '\n'%(self.ns_lower))

        # class boilerplate
        self.c.write('static void\n'
                     '%sobject_manager_client_init (%sObjectManagerClient *manager)\n'
                     '{\n'
                     '}\n'
                     '\n'%(self.ns_lower, self.namespace))
        self.c.write('static void\n'
                     '%sobject_manager_client_class_init (%sObjectManagerClientClass *klass)\n'
                     '{\n'
                     '}\n'
                     '\n'%(self.ns_lower, self.namespace))

        self.c.write('static GType\n'
                     '_%sobject_manager_client_get_proxy_type_func (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data)\n'
                     '{\n'
                     %(self.ns_lower))
        self.c.write('  static gsize once_init_value = 0;\n'
                     '  static GHashTable *lookup_hash;\n'
                     '  GType ret;\n'
                     '\n'
                     '  if (g_once_init_enter (&once_init_value))\n'
                     '    {\n'
                     '      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);\n')
        for i in self.ifaces:
            self.c.write('      g_hash_table_insert (lookup_hash, "%s", GSIZE_TO_POINTER (%sTYPE_%s_PROXY));\n'
                         %(i.name, i.ns_upper, i.name_upper))
        self.c.write('      g_once_init_leave (&once_init_value, 1);\n'
                     '    }\n')
        self.c.write('  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));\n'
                     '  if (ret == (GType) 0)\n'
                     '    ret = G_TYPE_DBUS_PROXY;\n')
        self.c.write('  return ret;\n'
                     '}\n'
                     '\n')

        self.c.write('GDBusProxyTypeFunc\n'
                     '%sobject_manager_client_get_proxy_type_func (void)\n'
                     '{\n'
                     '  return _%sobject_manager_client_get_proxy_type_func;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_lower))

        # constructors
        self.c.write('void\n'
                     '%sobject_manager_client_new (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", _%sobject_manager_client_get_proxy_type_func, NULL);\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower))
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_sync (\n'
                     '    GDBusConnection        *connection,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", _%sobject_manager_client_get_proxy_type_func, NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('\n')
        self.c.write('void\n'
                     '%sobject_manager_client_new_for_bus (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GAsyncReadyCallback     callback,\n'
                     '    gpointer                user_data)\n'
                     '{\n'
                     '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", _%sobject_manager_client_get_proxy_type_func, NULL);\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_for_bus_finish (\n'
                     '    GAsyncResult        *res,\n'
                     '    GError             **error)\n'
                     '{\n'
                     '  GObject *ret;\n'
                     '  GObject *source_object;\n'
                     '  source_object = g_async_result_get_source_object (res);\n'
                     '  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n'
                     '  g_object_unref (source_object);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower))
        self.c.write('GDBusObjectManager *\n'
                     '%sobject_manager_client_new_for_bus_sync (\n'
                     '    GBusType                bus_type,\n'
                     '    GDBusObjectManagerClientFlags  flags,\n'
                     '    const gchar            *name,\n'
                     '    const gchar            *object_path,\n'
                     '    GCancellable           *cancellable,\n'
                     '    GError                **error)\n'
                     '{\n'
                     '  GInitable *ret;\n'
                     '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", _%sobject_manager_client_get_proxy_type_func, NULL);\n'
                     '  if (ret != NULL)\n'
                     '    return G_DBUS_OBJECT_MANAGER (ret);\n'
                     '  else\n'
                     '    return NULL;\n'
                     '}\n'
                     '\n'
                     %(self.ns_lower, self.ns_upper, self.ns_lower))
        self.c.write('\n')

    # ---------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_intro()
        self.generate_generic_marshaller()
        self.declare_types()
        for i in self.ifaces:
            self.c.write('/* ------------------------------------------------------------------------\n'
                         ' * Code for interface %s\n'
                         ' * ------------------------------------------------------------------------\n'
                         ' */\n'
                         '\n'%(i.name))
            self.generate_introspection_for_interface(i)
            self.generate_interface(i)
            self.generate_property_accessors(i)
            self.generate_signal_emitters(i)
            self.generate_method_calls(i)
            self.generate_method_completers(i)
            self.generate_proxy(i)
            self.generate_stub(i)
        self.generate_object_manager_client()
        self.generate_outro()
